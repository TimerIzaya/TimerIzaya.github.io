---
layout:     post
title:      Mysql锁总结
subtitle:   锁就完事了
date:       2021-12-2
author:     Timer
header-img: img/the-first.png
catalog: false
tags:
    - Mysql
    - 数据库

---

## 全局锁

```mysql
Flush tables with read lock;
```

FTWRL，简单的说就是让整个数据库变为可读状态，所有DDL、增删改操作都会被阻塞。

![image-20211202220659031](https://gitee.com/timerizaya/timer-pic/raw/master/img/image-20211202220659031.png) 

对应的解锁语句为：

```mysql
unlock tables
```

全局锁主要用于全库逻辑备份，但是官方默认全库逻辑备份的工具是mysqldump。当用参数--single-transaction的时候，会启动一个事务，获得一致性视图。而由于MVCC 支持，这个过程可以正常更新。

顺便记录一波逻辑备份语句。

```shell
mysqldump -u[] -p[] [database] [table] > [file]; # 备份指定库-表
mysql -u[] -p[] [database] < [file]; #指定库导入
```

一致性读是很好，但是前提是引擎要支持可重复读的隔离级别。比如Myisam不支持事务，那么它备份时候的一致性就没法保证。所以必须要FTWRL了。

想要全库只读，还有一种方法是 **set global read_only = true**，直接修改配置。但是不推荐这样做。

- 有些系统要用全局变量来判断是否是主从。
- 异常处理机制有差异。如果是FTWRL的话，客户端异常断开，那么这个锁会被释放，不影响整个库。而设置read_only的话，则会一直保持只读状态，会导致长期不可写的状态，风险较大。

  

## 表级锁

表级的锁有两种，表锁和MDL（meta data lock）。

**表锁就是指定表的全局锁：**

```mysql
lock table q_bind read/write;

unlock tables #释放锁
```

对于Innodb这种支持行锁的引擎，一般不用这个。

**元数据锁：**

**元数据锁用来保证对象的并发访问时数据的一致性。**

当使用dml的时候，会增加对表的读锁，读锁之间不冲突。

当使用ddl的时候，会增加对表的写锁，写锁是独占的。

并且dml锁，是事务完全提交才会释放的。

**比如：**

事务1里全是dml语句，事务1执行。

之后事务2里全是dml语句，由于读锁不冲突，事务2同样并发执行。

之后事务3里有ddl语句，事务1和2还在执行，占用读锁，所以ddl阻塞。

可怕的是后续事务456里全是dml，同样被阻塞。

由于客户端的重连机制，超时后会再起一个session不断请求，那么线程很快就会爆满。

如果这个时候有一个小表，访问很频繁，但是又必须要加一个字段。那么比较理想的做法是：

**对ddl设置等待时间，如果在这个指定时间里拿不到锁，那么就放弃，一会儿继续请求。**

  



## 全局锁和表锁的总结：

- 全局锁主要用于逻辑备份。对于Innodb的引擎，用--single-transaction比较友好。
- 表锁一般是引擎不支持行锁才会用到。如果发现程序中有lock tables这种语句，那大概率可能是引擎还是MyISAM这种，没有更新。
- MDL直到事务结束才会释放，表结构更新的时候，注意不要阻塞DDL！

  



## 实际场景应用：

**当从库用--single-transaction逻辑备份的时候，如果从主库中binlog传来一个对表T的DDL会怎么样？**

先看逻辑备份的整体步骤：

```mysql
set session transaction isolation level repeatable read; #确保隔离级别为RR

start transaction with consistent snapshot; #确保这句执行完就可以获得一个一致性视图，用于逻辑备份

savepoint sp; #开始备份，记录当前sp，防止中途表结构变化

show create table t; #获得表结构

select * from t; #导入数据

rollback to savepoint sp; #返回sp，表T备份结束

#开始备份其他表
```



如果在获得表结构之前，那么ddl会在t上应用成功，但是在导出操作的时候会显示  **“ERROR 1412 (HY000): Table definition has changed, please retry transaction”**。

如果在 sp 和 roll back to sp 之间，由于sp会获得MDL，此时对t1的所有ddl都会被阻塞，造成**主从延迟**。

如果在sp之后，那么没有问题。

  

## 行锁

行锁顾名思义就是针对行的锁，比如事务A更新了一行，事务B也要更新这行，那必须等A把锁释放了才可以更新。

行锁一个重要的性质就是**两阶段锁协议**：

| 事务A                                                     | 事务B                                                        |
| --------------------------------------------------------- | ------------------------------------------------------------ |
| **begin;**                                                |                                                              |
| **update stu set name = "fuck the school" where id = 1;** |                                                              |
|                                                           | **begin;**                                                   |
|                                                           | **update stu set name = "i can't agree more" where id = 1;** |
| **commit;**                                               |                                                              |

可以验证，B的更新会被堵塞，A持有对id = 1这行的行锁，直到A commit才会释放。

也就是说，**InnoDB事务中，行锁需要的时候就会加上，但是要事务结束了才会释放。这就是二阶段锁协议。**

也就是说，在实际开发中，要把最可能造成锁冲突的、影响并发的锁往后放。

比如做电影购票系统的时候，买票可能需要三个操作：

1. 从顾客账户扣钱
2. 给影院账户加钱
3. 记录一条交易信息

那么如果用户A和B同时买票，操作2会死锁减少效率。最好的方式是把2和3调换一下，这样就可以减少事务之间的锁等待，提高并发度。

**但是，在高并发情况下，行锁依然会导致死锁的出现：**

| 事务A                                           | 事务B                                           |
| ----------------------------------------------- | ----------------------------------------------- |
| **begin;**                                      | begin;                                          |
| update stu set name = "byebye ujs" where id = 1 |                                                 |
|                                                 | update stu set name = "byebye ujs" where id = 2 |
| update stu set name = "izaya" where id = 2      |                                                 |
|                                                 | update stu set name = "izaya" where id = 1      |
| commit;                                         | commit;                                         |

事务A拿了id = 1的行锁，事务B又拿了id = 2的行锁。

事务A等待事务B释放id = 2的行锁，事务B等待事务A释放id = 1的行锁。

对此有两种策略：

- **设置死锁等待时间，超时退出。**这不是很可行，超时参数innodb_lock_wait_timeout，如果过大那么客户体验差，如果过小那么容易误伤一些非死锁的锁。

- **开启死锁检测。**发现死锁，主动回滚死锁链中的某个事务，打破死锁。将参数innodb_deadlock_detect设置为on，表示开启这个逻辑。虽然这个方法最简单可行，并且默认本身就是开启的，但是它也有相当大的额外负担。

  比如上面说的买票操作2，假设有1000个用户同时操作。那么每个新来的被阻塞的线程，都得判断是否是自己导致了死锁，这是一个复杂度为O(n)的操作，那么检测操作就是百万级别的次数，容易消耗CPU资源，虽然CPU利用率高，但是处理事务的性能却很差。

##### 那么对于热点行的死锁，怎么解决？

该问题的关键在于死锁检测浪费CPU资源！

- **如果能保证这个业务一定不会出现死锁**，**可以临时把死锁检测关掉。**
- **控制并发度。**如果有中间件，可以考虑在中间件中实现。如果能改源码，可以从mysql源码角度实现。当然这些都是可遇不可求的了，最方便的是从设计上做优化。比如影院账户，可以放在10个记录上，账户总额等于这10个记录的总和，每次增加的时候，随机一条加，这样冲突概率变为1/10，也可以减少死锁检测次数。但是这种做法要照顾到细节，比如单个记录小于0了，要在业务逻辑上多加处理。

























