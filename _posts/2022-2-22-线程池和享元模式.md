---
5layout:     post
title:      线程池和享元模式
subtitle:   Core Of JUC
date:       2022-2-24
author:     Timer
header-img: img/the-first.png
catalog: false
tags:
    - JUC
    - 设计模式


---

## 享元模式

如果在一个系统中存在多个相同的对象，那么只需要共享一份对象的拷贝,而不必为每一次使用都创建新的对象。

享元模式目的节约内存，提高系统性能。

比如JAVA中的String，保证同样内容的多个字符串只指向一个对象。

比如Integer等基本类型的包装类，几乎都有一定的缓存池，这也是享元模式的体现。

最典型的还是线程池的应用，是**享元模式**和**生产者消费者模式**以及JUC各种常用方法的完美组合。



## 撸个简单的线程池

### 线程池需要满足的几点：

1. 生产者是用户execute执行的任务，消费者是线程池，阻塞队列是中间缓冲。
2. 超过核心数时，也就是CPU满载，需要实现一个阻塞队列来缓冲。
3. 当阻塞队列已满，需要一个拒绝策略来解决面临的情况。

### 阻塞队列的实现

```java
class BlockingQueue<T> {

    private Deque<T> queue = new LinkedList<>();

    private ReentrantLock lock = new ReentrantLock();

    //生产者条件变量
    private Condition fullWaitSet = lock.newCondition();

    //消费者条件变量
    private Condition emptyWaitSet = lock.newCondition();

    //阻塞队列的最大容量
    private int capacity;

    public BlockingQueue(int capcity) {
        this.capacity = capcity;
    }

    //获取队列大小，需要保证线程安全
    public int size() {
        lock.lock();
        try {
            return queue.size();
        } finally {
            lock.unlock();
        }
    }

    //从阻塞队列头部获取任务，无超时设置
    public T get() {
        lock.lock();
        try {
            //队列为空，无限等待
            while (queue.isEmpty()) {
                try {
                    emptyWaitSet.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            //队列有任务，取头部任务
            T first = queue.pollFirst();
            fullWaitSet.signal(); //唤醒写线程
            return first;
        } finally {
            lock.unlock();
        }
    }

    //添加任务到阻塞队列尾部，无超时设置
    public void put(T task) {
        lock.lock();
        try {
            //队列已满，无限等待
            while (queue.size() == capacity) {
                try {
                    log.debug("核心满载，无限等待加入阻塞队列 : {}", task);
                    fullWaitSet.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            //队列未满，添加任务
            queue.addLast(task); //增队尾
            log.debug("核心满载，加入阻塞队列 : {}", task);
            emptyWaitSet.signal(); //唤醒读线程
        } finally {
            lock.unlock();
        }
    }

    //获取阻塞队列，带超时设置
    public T poll(long timeout, TimeUnit timeUnit) {
        lock.lock();
        try {
            //把超时时间统一转换为纳秒
            long nanos = timeUnit.toNanos(timeout);
            //队列为空，进入等待
            while (queue.isEmpty()) {
                try {
                    if (nanos <= 0) {
                        return null;
                    }
                    //notify过后还是会加入到entryList竞争，可能多次进入此循环
                    //awaitNanos默认把每次等待的时间都减去
                    nanos = emptyWaitSet.awaitNanos(nanos);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            T first = queue.pollFirst(); //取队头
            fullWaitSet.signal(); //唤醒写线程
            return first;
        } finally {
            lock.unlock();
        }
    }

    //写阻塞队列，带超时设置
    public void offer(T task, long timeout, TimeUnit timeUnit) {
        lock.lock();
        try {
            long nanos = timeUnit.toNanos(timeout);
            while (queue.size() == capacity) {
                try {
                    if (nanos <= 0) {
                        return;
                    }
                    log.debug("核心满载，等待加入阻塞队列 : {}", task);
                    nanos = fullWaitSet.awaitNanos(nanos);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            queue.addLast(task); //增队尾
            log.debug("核心满载，加入阻塞队列 : {}", task);
            emptyWaitSet.signal(); //唤醒读线程
        } finally {
            lock.unlock();
        }
    }

    //核心满载，依然需要放入线程池
    //如果队列未满，直接添加即可
    //如果队列满了，根据拒绝策略选择怎么处理
    public void tryPut(RejectPolicy<T> rejectPolicy, T task) {
        lock.lock();
        try {
            if (queue.size() == capacity) {
                rejectPolicy.reject(this, task);
            } else {
                queue.addLast(task);
                emptyWaitSet.signal();
            }
        } finally {
            lock.unlock();
        }
    }
}

```



### 拒绝策略接口实现

```java
//声明为函数式接口，让调用者选择queue应该怎么处理task
@FunctionalInterface
interface RejectPolicy<T> {
    void reject(BlockingQueue<T> queue, T task);
}
```



### 线程池实现

```java
@Slf4j(topic = "c.ThreadPool")
public class TimerThreadPool {

    //任务队列
    private BlockingQueue<Runnable> taskQueue;

    //线程集合
    private HashSet<Worker> workers = new HashSet<>();

    //核心线程数
    private int coreSize;

    //获取任务超时时间
    private long timeout;

    private TimeUnit timeUnit;

    //拒绝策略
    private RejectPolicy<Runnable> rejectPolicy;

    public TimerThreadPool(int coreSize, long timeout, TimeUnit timeUnit, int queueCapacity, RejectPolicy<Runnable> rejectPolicy) {
        this.coreSize = coreSize;
        this.timeout = timeout;
        this.timeUnit = timeUnit;
        this.taskQueue = new BlockingQueue<>(queueCapacity);
        this.rejectPolicy = rejectPolicy;
    }

    public void execute(Runnable task) {
        //当任务数没超过coreSize时，直接new一个worker执行
        //否则交给阻塞队列处理
        synchronized (workers) {
            if (workers.size() < coreSize) {
                Worker worker = new Worker(task);
                workers.add(worker);
                worker.start();
            } else {
                taskQueue.tryPut(rejectPolicy, task);
            }
        }
    }

    //Worker数目等于Core数目
    //只要线程池有任务就一直run
    //当线程池没任务就移除
    class Worker extends Thread {

        private Runnable task;

        public Worker(Runnable task) {
            this.task = task;
        }

        public void run() {
            //当task不为空，直接执行
            //当task为空，从任务队列中获取任务(带超时)，再执行
            while (task != null || (task = taskQueue.poll(timeout, timeUnit)) != null) {
                try {
                    log.debug("正在执行 : {}", task);
                    task.run();
                } finally {
                    task = null; //任务执行完毕
                }
            }
            // 当前worker无事可做，移除
            synchronized (workers) {
                log.debug("Worker {} 被移除", this);
                workers.remove(this);
            }
        }
    }
}
```



## ThreadPoolExecutor

大概原理了解后，再去看JDK提供的线程池，一目了然。

### ThreadPoolExecutor构造方法七大参数

- **corePoolSize**：核心线程数目 (最多保留的线程数)
- **maximumPoolSize** ：最大线程数目
- **keepAliveTime** ：生存时间（针对救急线程）
- **unit 时间单位 **：生存时间（针对救急线程）
- **workQueue** ：阻塞队列
- **threadFactory** ：线程工厂 ，初始化线程可以附带做一些操作，通常用来给线程起个名字。
- **handler** ：拒绝策略

### ThreadPoolExecutor执行流程

1. 刚开始执行，有任务提交到线程池，线程池创建一个线程来执行任务。
2. 当线程数达到corePoolSize，且没有空闲线程，这时候加入任务就会被加到queue中。
3. 当阻塞的任务超过了queue的容量，创建 maximumPoolSize - corePoolSize 数目的线程来救急。
4. 如果线程到达 maximumPoolSize 仍然有新任务这时会执行拒绝策略。
5. 当高峰过去后，超过corePoolSize 的救急线程如果一段时间没有任务做，需要结束节省资源，这个时间由keepAliveTime 和 unit 来控制。

### JDK提供的拒绝策略

- **AbortPolicy**：让调用者抛出 RejectedExecutionException 异常，这是默认策略
- **CallerRunsPolicy**：让调用者运行任务
- **DiscardPolicy**：放弃本次任务
- **DiscardOldestPolicy**：放弃队列中最早的任务，本任务取而代之

### 其他框架提供的拒绝策略

- **Dubbo **：在抛出 RejectedExecutionException 异常之前会记录日志，并 dump 线程栈信息，方便定位问题
- **Netty** ：是创建一个新线程来执行任务
- **ActiveMQ** ：带超时等待（60s）尝试放入队列，类似我们之前自定义的拒绝策略
- **PinPoint** ：它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略

### JDK提供的几种线程池

- **newFixedThreadPool**

  **特点**：核心线程 == 最大线程数，没有急救任务，因此也不需要超时时间。阻塞队列是无界的，可以放任意多的数目。

  > 使用场景：适用于任务量已知，相对耗时的任务。

- **newCachedThreadPool**

  **特点**：核心线程数为0，最大线程数是Integer.MAX_VALUE，急救线程空闲生存60s，这意味着所有线程都是救急线程。

  同时它的队列用的是SynchronousQueue，没有容量，只有存了才能取。

  > 使用场景：整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完毕，空闲 1分钟后释放线程。 适合任务数比较密集，但每个任务执行时间较短的情况

- **newSingleThreadExecutor**

  > 使用场景：希望多个任务串行执行。线程数固定为 1，任务数多于 1 时，会放入无界队列排队。任务执行完毕，这唯一的线程也不会被释放。

  **这种线程池存在的意义是什么？**

  - 自己创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施。但是线程池还会新建一个线程，保证池的正常工作。

  - newSingleThreadExecutor用了装饰器模式，只暴露了能用的接口，一些特有的方法被屏蔽了。

  - 之所以不用核心为1的newFixedThreadPool，理由同上。  

    

### 线程池提交任务的几种方法

```java
// 执行任务
void execute(Runnable command);
// 提交任务 task，用返回值 Future 获得任务执行结果
<T> Future<T> submit(Callable<T> task);
// 提交 tasks 中所有任务
<T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)
 throws InterruptedException;
// 提交 tasks 中所有任务，带超时时间
<T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks,
 long timeout, TimeUnit unit)
 throws InterruptedException;
// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消
<T> T invokeAny(Collection<? extends Callable<T>> tasks)
 throws InterruptedException, ExecutionException;
北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090
7) 关闭线程池
shutdown
shutdownNow
// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消，带超时时间
<T> T invokeAny(Collection<? extends Callable<T>> tasks,
 long timeout, TimeUnit unit)
 throws InterruptedException, ExecutionException, TimeoutException;
```



### 关闭线程池的几种方法

##### 首先线程池有五种状态，其中线程池的状态和线程数量用一个int表示，前3位为状态，后29位为线程数量。方便一次CAS进行赋值。

| 状态       | 高三位 | 说明                                             |
| ---------- | ------ | ------------------------------------------------ |
| RUNNING    | 111    | 正在运行。                                       |
| SHUTDOWN   | 000    | 不会接受新任务，但会处理阻塞队列剩余任务。       |
| STOP       | 001    | 中断当前执行的任务，抛弃阻塞队列剩余任务。       |
| TIDYING    | 010    | 所有任务执行完毕，活动线程为0，即将进入011状态。 |
| TERMINATED | 011    | 终结。                                           |

- **shutdown方法**：线程池状态变为 SHUTDOWN。
- **shutdownNow方法**：线程池状态变为STOP。











