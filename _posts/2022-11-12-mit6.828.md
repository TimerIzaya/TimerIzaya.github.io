---
layout:     post
title:      从6.S081中学到了什么
subtitle:   
date:       2022-10-29
author:     Timer
header-img: img/the-first.png
catalog: false
tags:
    - OS
 

---

# Lecture 1: O/S overview

- ### fork、僵尸进程、孤儿线程

  **fork作用**就是把当前进程的内存块复制一份，当然也包含了程序计数器，所以fork出的子进程是从fork语句下面开始执行的。

  **僵尸进程的定义**是执行完但是还没回收的子进程，其PCB还在进程表里留着。

  实际代码中就是子进程没被wait。wait除了等待子进程的作用外，还有回收子进程的作用，也就是把子进程PCB从进程表里删了。

  wait = wait + delete 

  no wait = no delete

  **但是为什么要有僵尸进程？为什么死掉的子进程PCB还要留着？**

  创建进程的唯一系统调用是fork()，也就是进程和进程之间是树形的结构。
  
  父进程下一步可能取决于执行完的子进程的退出状态和资源使用情况，比如子进程是否异常退出，子进程的CPU使用率等等。
  
  
  
  **孤儿进程的定义**是子进程还没执行完，父进程就执行完了，那么子进程就成了所谓的孤儿。
  
  但是不用太过于在意，init进程会收养这些孤儿，并定期调用wait()。
  
  所以最好fork出来的子进程要用wait去回收，虽然无伤大雅，但是子进程迟迟不销毁也挺麻烦的。
  
  
  
  
- ### 文件描述符

  JAVA的NIO里所谓的channel就是文件描述符，**文件描述符就是一个整数**，每个文件描述符对应一个文件。

  每个进程诞生的时候，都会有一个fd列表，初始化三个fd，0是输入文件，1是输出文件，2是报错文件。

  此后再open一个文件，其fd从4开始递增。

  如果使用close释放了这个fd，那么新的fd会占用这个释放的fd。例如当前进程fd列表为123456，释放了4，列表为12356，那么新open的文件的fd就为4。

  **当然，不同进程的不同fd也可能指向同一个文件。比如进程A的6和进程B的16，可能都是指向XXX.txt** 

  

- ### 管道

  没什么好说的，C语言中pipe方法可以获得输入和输出的fd，fork方法再次pipe又是一对输入和输出的fd。由于是单向通信，所以这四个fd，只要对其中两个操作即可，另外两个记得要close。

  另外，在linux指令中，比如`ps -a | grep xxx`， 竖线之前的输出结果，会作为竖线之后输入的结果，也是管道。



























