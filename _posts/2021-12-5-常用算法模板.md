---
layout:     post
title:      常用算法模板
subtitle:   理应信手拈来
date:       2021-12-5
author:     Timer
header-img: img/the-first.png
catalog: false
tags:
    - Algorithm

---

#### 快速幂（迭代）

```java
    public double myPow(double x, int n) {
        long N = Math.abs((long)n);
        double ans = 1;
        while(N > 0){
            if((N & 1) == 1){
                ans *= x;
            }
            x *= x;
            N /= 2;
        }
        return n >= 0 ? ans : 1 / ans;
    }
```

#### 快速幂（递归）

```java
    public double dfs(double x, long n){
        if(n == 0){
            return 1;
        }
        double y = dfs(x, n / 2);
        return (n & 1) == 1 ? y * y * x : y * y;
    }

    public double myPow(double x, int n) {
        long N = Math.abs((long)n);        
        return n < 0 ? 1 / dfs(x, N) : dfs(x, N);
    }
```

#### 快速乘（实际运用需要考虑溢出）

```java
    public long quickAdd(int x, int n) {
        long N = Math.abs((long) n);
        long ans = 0;
        while(N > 0){
            if((N & 1) == 1){
                ans += x;
            }
            x += x;
            N /= 2;
        }
        return n < 0 ? -ans : ans;
    }
```

#### 一个长度为k的窗口，求最大的一个窗口

```java
    public int[] maxSumOfOneSubarray(int[] nums, int k) {
        int n = nums.length;
        int[] ans = new int[1];
        int win = 0, maxWin = 0;
        for (int i = 0; i < n; i++) {
            win += nums[i];
            if (i >= k - 1) {
                if (win > maxWin) {
                    maxWin = win;
                    ans[0] = i - k + 1;
                }
                win -= nums[i - k + 1];
            }
        }
        return ans;
    }
```

#### 三个长度为k的窗口，互不重叠，求三个窗口的最大值（**需要反复理解**）

其实本质相当于一个长度为3 * k的大窗口遍历整个数组。

首先，win3需要知道win1和win2什么时候是最优解，当win3 + max(win1 + win2)为最大时，更新对应下标。

其次，win2需要知道win1什么时候是最优解，当win2 + max(win)为最大的时候，更新对应下标。

```java
    public int[] maxSumOfThreeSubarrays(int[] nums, int k) {
        int n = nums.length;
        int win1 = 0, win2 = 0, win3 = 0;
        int maxWin1 = 0, maxWin12 = 0, maxWin123 = 0;
        int maxWin1Index = 0, maxWin12Index0 = 0, maxWin12Index1 = 0;
        int[] ans = new int[3];
        for(int i = k * 2 ; i < n; i++){
            win1 += nums[i - k * 2];
            win2 += nums[i - k];
            win3 += nums[i];
            if(i >= k * 3 - 1){
                if(win1 > maxWin1){
                    maxWin1 = win1;
                    maxWin1Index = i - 3 * k + 1;
                }
                if(maxWin1 + win2 > maxWin12){
                    maxWin12 = maxWin1 + win2;
                    maxWin12Index0 = maxWin1Index;
                    maxWin12Index1 = i - 2 * k + 1;
                }
                if(maxWin12 + win3 > maxWin123){
                    maxWin123 = maxWin12 + win3;
                    ans[0] = maxWin12Index0;
                    ans[1] = maxWin12Index1;
                    ans[2] = i - k + 1;
                }
                win1 -= nums[i - 3 * k + 1];
                win2 -= nums[i - 2 * k + 1];
                win3 -= nums[i - 1 * k + 1];
            }
        }
        return ans;
    }
```

