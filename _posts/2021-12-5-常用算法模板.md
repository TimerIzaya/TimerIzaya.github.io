---
layout:     post
title:      常用算法模板
subtitle:   理应信手拈来
date:       2021-12-5
author:     Timer
header-img: img/the-first.png
catalog: false
tags:
    - Algorithm

---

#### 快速幂（迭代）

```java
    public double myPow(double x, int n) {
        long N = Math.abs((long)n);
        double ans = 1;
        while(N > 0){
            if((N & 1) == 1){
                ans *= x;
            }
            x *= x;
            N /= 2;
        }
        return n >= 0 ? ans : 1 / ans;
    }
```

#### 快速幂（递归）

```java
    public double dfs(double x, long n){
        if(n == 0){
            return 1;
        }
        double y = dfs(x, n / 2);
        return (n & 1) == 1 ? y * y * x : y * y;
    }

    public double myPow(double x, int n) {
        long N = Math.abs((long)n);        
        return n < 0 ? 1 / dfs(x, N) : dfs(x, N);
    }
```

#### 快速乘（实际运用需要考虑溢出）

```java
    public long quickAdd(int x, int n) {
        long N = Math.abs((long) n);
        long ans = 0;
        while(N > 0){
            if((N & 1) == 1){
                ans += x;
            }
            x += x;
            N /= 2;
        }
        return n < 0 ? -ans : ans;
    }
```

#### 一个长度为k的窗口，求最大的一个窗口

```java
    public int[] maxSumOfOneSubarray(int[] nums, int k) {
        int n = nums.length;
        int[] ans = new int[1];
        int win = 0, maxWin = 0;
        for (int i = 0; i < n; i++) {
            win += nums[i];
            if (i >= k - 1) {
                if (win > maxWin) {
                    maxWin = win;
                    ans[0] = i - k + 1;
                }
                win -= nums[i - k + 1];
            }
        }
        return ans;
    }
```

#### 三个长度为k的窗口，互不重叠，求三个窗口的最大值（**需要反复理解**）

其实本质相当于一个长度为3 * k的大窗口遍历整个数组。

首先，win3需要知道win1和win2什么时候是最优解，当win3 + max(win1 + win2)为最大时，更新对应下标。

其次，win2需要知道win1什么时候是最优解，当win2 + max(win)为最大的时候，更新对应下标。

```java
    public int[] maxSumOfThreeSubarrays(int[] nums, int k) {
        int n = nums.length;
        int win1 = 0, win2 = 0, win3 = 0;
        int maxWin1 = 0, maxWin12 = 0, maxWin123 = 0;
        int maxWin1Index = 0, maxWin12Index0 = 0, maxWin12Index1 = 0;
        int[] ans = new int[3];
        for(int i = k * 2 ; i < n; i++){
            win1 += nums[i - k * 2];
            win2 += nums[i - k];
            win3 += nums[i];
            if(i >= k * 3 - 1){
                if(win1 > maxWin1){
                    maxWin1 = win1;
                    maxWin1Index = i - 3 * k + 1;
                }
                if(maxWin1 + win2 > maxWin12){
                    maxWin12 = maxWin1 + win2;
                    maxWin12Index0 = maxWin1Index;
                    maxWin12Index1 = i - 2 * k + 1;
                }
                if(maxWin12 + win3 > maxWin123){
                    maxWin123 = maxWin12 + win3;
                    ans[0] = maxWin12Index0;
                    ans[1] = maxWin12Index1;
                    ans[2] = i - k + 1;
                }
                win1 -= nums[i - 3 * k + 1];
                win2 -= nums[i - 2 * k + 1];
                win3 -= nums[i - 1 * k + 1];
            }
        }
        return ans;
    }
```

#### 字典序的下一个排列（lc31）

![1556953035922.png](https://gitee.com/timerizaya/timer-pic/raw/master/img/4169e8e0c8b4d71d4d32b4f50b09a57c0ea951cb4bdbd16a785d5847959e261f-1556953035922.png)

首先，如果是完全逆序的数组，那么这个值一定是最大的，直接逆序即可，如果不完全逆序，则说明它还有更大的下一个排列。

逆序意味着最大，所以改动点必不可能在逆序中，改动逆序子序列意味着这个排列是比当前小的。

所以先找到最右侧的第一个升序，此处为改动点1。（比如127431，2为改动点1）

其次找到改动点1之后，找离他右侧最远的大于它的改动点2，因为越右这个数影响越小。（比如127431，3为改动点2）

交换这两个改动点的值。（比如127431，交换完为137421）

最后由于交换完可能乱序，将改动点1之后所有的值逆序排序。

```java
    public void nextPermutation(int[] nums) {
        int n = nums.length;
        int one = -1, two = -1;
        for(int i = n - 2; i >= 0; i--){
            if(nums[i + 1] > nums[i]){
                one = i;
                break;
            }
        }
        if(one == -1){
            reverse(nums, 0, n - 1);
            return;
        }
        for(int i = one + 1; i < n; i++){
            if(nums[i] > nums[one]){
                two = i;
            }
        }
        swap(nums, one, two);
        reverse(nums, one + 1, n - 1);
    }
    public void swap(int[] arr, int i, int j){
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }

    public void reverse(int[] arr, int i, int j){
        while(i < j){
            swap(arr, i++, j--);
        }
    }
```

