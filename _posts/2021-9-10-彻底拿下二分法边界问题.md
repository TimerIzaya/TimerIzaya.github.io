---
layout:     post
title:      彻底拿下二分法边界问题
subtitle:   边界真的很重要
date:       2021-9-10
author:     Timer
header-img: img/the-first.png
catalog: false
tags:
    - Algorithm


---

# **以最简单的二分查找为例：**

https://leetcode-cn.com/problems/binary-search/



## **首先要搞清楚二分法中三个变量L R M的实际含义**

L：左边界

R：右边界

M：中间值（判断是否查询到目标值的依据）

这里以数组 arr = {1,3,5,7,9}为例

### 第一步：

首先要解决的问题就是，**while(L<R)** 和 **while(L <= R)**,到底有什么区别？

L和R本质上就是我们现在在搜索的区间，是否能相等则取决于区间的开闭关系。

如果这个区间是左闭右闭的话，L和R分别为0和4，则说明L和R可以在0到4的任意下标的位置相遇，此时我们使用**(L <= R)**。

如果这个区间是左闭右开的话，L和R分别为0和5，则说明L和R在极端情况下会越界，此时我们使用**while(L<R)**。

```
    //左闭右开
    public int search(int[] nums, int target) {
        int n = nums.length;
        int L = 0, R = n;
        while(L < R){
            //todo
        }
        return -1;
    }
 
    //左闭右闭
    public int search(int[] nums, int target) {
        int n = nums.length;
        int L = 0, R = n - 1;
        while(L <= R){
            //todo
        }
        return -1;
    }
```



### 第二步：

其次要解决的问题就是，如果这个时候M不是目标下标，怎么收缩区间？

上面说了，L和R就是我们现在能搜索的范围，所以二分之后的**两个小区间边界约束**应和**二分前的大区间**约束一致。

如果初始区间是**左闭右闭**，那我们要保证二分之后的自区间也是**左闭右闭**，也就是在此区间内任何值都能取到，则L = M + 1， R = M -1。

```
class Solution {
    public int search(int[] nums, int target) {
        int n = nums.length;
        int L = 0, R = n - 1;
        while(L <= R){
            int M = L + (R - L) / 2;
            if(target > nums[M]){
                L = M + 1;
            }else if (target < nums[M]){
                R = M - 1;
            }else{
                return M;
            }
        }
        return -1;
    }
}
```

**如果初始区间是左闭右开，**那我们要保证二分之后的自区间也是**左闭右开**，则L = M + 1，而 R = M，因为M这个值后面是不会取到的，满足了**左闭右开**的约束。

```
class Solution {
    public int search(int[] nums, int target) {
        int n = nums.length;
        int L = 0, R = n;
        while(L < R){
            int M = L + (R - L) / 2;
            if(target > nums[M]){
                L = M + 1;
            }else if (target < nums[M]){
                R = M;
            }else{
                return M;
            }
        }
        return -1;
    }
}
```

**如果初始区间是左开右闭，**那我们要保证二分之后的自区间也是**左开右闭**，则L = M，而 R = M - 1，因为M这个值后面是不会取到的，满足了**左开右闭**的约束。（这里要注意M的取值方法有所不同）

```
class Solution {
    public int search(int[] nums, int target) {
        int n = nums.length;
        int L = -1, R = n - 1;
        while(L < R){
            int M = R - (R - L) / 2;
            if(target > nums[M]){
                L = M;
            }else if (target < nums[M]){
                R = M - 1;
            }else{
                return M;
            }
        }
        return -1;
    }
}
```



### 总结

这里描述的只是一般情况，二分法变种很多，很多时候不要求找到目标值，只要求区间不断收缩，重视边界左右到底是开是闭，利用极限情况观察L和R的位置关系，可以有效的破解问题。