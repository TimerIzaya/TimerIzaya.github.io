---
layout:     post
title:      拿下MVCC
subtitle:   数据库的黑科技
date:       2021-12-11
author:     Timer
header-img: img/the-first.png
catalog: false
tags:
    - Mysql
    - 数据库

---

## MVCC

全名为Muti-Version Concurrency Control，多版本并发控制。

在Mysql中，有两种视图的概念。

- **view** : 简单说就是拷贝的查询结果集
- **consistent read view** : InnoDB在实现MVCC使用的一致性读视图，用于支持RC（read committed，读提交）和RR（repeatable read，可重复读）隔离级别的实现。它没有物理结构，作用是确定事务执行期间**能看到什么数据。**



## 快照在MVCC里是怎么工作的？

在RR级别的隔离中，事务启动就要创建快照，如果一个库有100G，mysql不可能拷贝100G的数据出来做个快照。

这就是MVCC的黑科技。

InnoDB为每个事务创建了一个transaction_id，在事务开始时向事务系统申请，严格递增。

每个记录，也就是每个行都有一个多个版本。比如对于某行来说：

**trx_id = 10，value = 100**

**trx_id = 15，value = 200**

**trx_id = 17，value = 500**

**trx_id = 25，value = 300（当前最新数据）**

也就是说不同的事务可能正在观察的行，其结果是不同的。

**这个时候undo log的作用也就提现出来了：回滚这行数据到合适的版本。**

所以可以发现一行数据的快照之所以可以固定，就是要把它回滚到事务开始时的那个版本。

当然，不可能保存所有行应该回滚到的版本，这样不仅本末倒置，也太笨了。

在实现上，InnoDB为每个事务创建了一个数组，用于存储在当前事务启动时，其他所有已启动但没提交的事务ID。

数组的最小ID为低水位，已经创建的事务最大ID为高水位。

如果当前行的row_trx_id小于低水位，则表示这个是已经提交的事务，**可见**。

如果当前行的row_trx_id在高低水位之间，则要判断这个版本是否由已提交的事务生成，**如果是，则可见，不然不可见**。

如果当前喊的row_trx_id大于高水位，则说明这个版本是由未来的事务生成的，**不可见**。

这个数组和高水位，**其实就是当前事务的一致性视图。**

举个例子，当前事务启动时的id为10，启动瞬间活跃的事务id有5 7 8，已经提交的事务id有1 2 3 4 6 9。

低水位为5，高水位为9。

如果当前行的row_trx_id为3，则说明是已经提交的事务，**可见**。

如果当前行的row_trx_id为6，在高低水位之间，但是活跃事务数组里又没有，说明是已提交的，**可见**。如果为7，存在于活跃事务数组中，说明还没提交，**则不可见**，需要回滚到可见的版本，7->6，undo log回滚该行版本到6。

如果当前行的row_trx_id为12，说明是未来事务创建的，**不可见**，需要回滚，12->9，undo log回滚该行版本到9.

**由此可见，InnoDB利用了“所有数据都有多个版本”的特性，实现了“秒级创建快照“的能力。**  



## 实际场景

假设id为1的行，k值默认为1。

|                    事务A                    |                            事务B                             |                事务C                 |
| :-----------------------------------------: | :----------------------------------------------------------: | :----------------------------------: |
| start transaction with consistent snapshot; |                                                              |                                      |
|                                             |         start transaction with consistent snapshot;          |                                      |
|                                             |                                                              | update t set k = k + 1 where id = 1; |
|                                             | update t set k = k + 1 where id = 1;<br />select k from t where id = 1; |                                      |
| select k from t where id = 1;<br />commit;  |                                                              |                                      |
|                                             |                           commit;                            |                                      |















