---
5layout:     post
title:      天池ADB高性能数组分析引擎比赛复盘
subtitle:   
date:       2022-3-14
author:     Timer
header-img: img/the-first.png
catalog: false
tags:
    - JUC
 


---

## Buffer和Cache

- Buffers 是对原始磁盘块的临时存储，也就是用来**缓存磁盘的数据**，通常不会特别大（20MB 左右）。这样，内核就可以把分散的写集中起来，统一优化磁盘的写入，比如可以把多次小的写合并成单次大的写等等。
- Cached 是从磁盘读取文件的页缓存，也就是用来**缓存从文件读取的数据**。这样，下次访问这些文件数据时，就可以直接从内存中快速获取，而不需要再次访问缓慢的磁盘。

## FileChannel需要知道的

- #### 4K对齐

  FileChannel 只有在一次写入 4kb 的整数倍时，才能发挥出实际的性能，这得益于 FileChannel 采用了 ByteBuffer 这样的内存缓冲区，让我们可以非常精准的控制写盘的大小，这是普通 IO 无法实现的。4kb 一定快吗？也不严谨，这主要取决你机器的磁盘结构，并且受到操作系统，文件系统，CPU 的影响，所以benchmark很重要，有时候32KB或者64KB才是最佳选择。

- #### 潮汐刷盘

  操作系统最终帮我们完成了 PageCache 到磁盘的最终写入，所以 FileChannel 提供了一个 force() 方法强制刷盘！

- #### 并发读ByteBuffer不要加锁！！！

  使用 ByteBuffer 提供的 duplicate 和 slice 这两个方法

## MMAP需要知道的

MMAP主要是省去了内核缓冲区复制到用户空间的过程，文件中的位置在虚拟内存中有了对应的地址，可以像操作内存一样操作这个文件，相当于已经把整个文件放入内存，但在真正使用到这些数据前却不会消耗物理内存，只有真正使用这些数据时，虚拟内存管理系统 VMS 才根据缺页加载的机制从磁盘加载对应的数据块到物理内存进行渲染。

但是要注意的是！！！

- MMAP 一次写入很小量数据的场景下才能表现出比 FileChannel 稍微优异的性能
- MMAP JAVA里一次只能映射2g，很恶心
- MMAP 使用的是虚拟内存，和 PageCache 一样是由操作系统来控制刷盘的，也要通过 force() 来手动控制
- MMAP回收要反射，很麻烦

## PMEM需要知道的

内存 DRAM 的访问延时在 80~100ns，固态硬盘 SSD 的访问延时在 10~100us，而持久内存介于两者之间，比内存慢 10 倍，比固态硬盘快 10~100 倍。

PMem 工作在 Memory Mode 时，是易失性的，这时候，你需要使用专门的一套系统指令去进行存取.

PMem 工作在 AppDirect Mode 时，可以直接把 PMem 当成一块磁盘来用，PMem 背后适配了一整套文件系统的指令，使得常规的文件操作可以完全兼容的跑在 PMem 之上。



## 小优化合集

- #### Parse Long

  首先判断19位之后是不是逗号或者换行，如果是的话，那直接循环展开，方便CPU向量化。

  如果不是，照常乘法，但是可以把每次减去字符0的操作提出来，最后统一减。

- #### 分支预测优化

  输入文件大概有 10G 左右，所有的字节都会经过 if 判断一次，而实际上，大多数的字符并不是 `\n` 和 `,` 。这会导致 CPU 被浪费在分支预测上。直接用while取代if。可优化24s！

- #### DirectByteBuffer和HeapByteBuffer

  不管采用哪个，JVM均会将数据首先拷贝至堆外内存中，所以无形中，使用`HeapByteBuffer`会多一次数据拷贝。

  （其实还是JAVA垃圾回收带来的问题，在垃圾回收时，堆内存的数据地址会发生移动并重排，而native方法接收的是address以及写入大小，address变动会带来致命的问题，但总不能设定在IO操作时，不能进行GC吧。又因为堆外内存不受GC约束，所以设计者将数据主动拷贝一份至堆外，来避免垃圾回收带来的尴尬；在java doc中也标注使用者尽量使用堆外内存以提高性能，此处不再赘述）

  

  

  





























