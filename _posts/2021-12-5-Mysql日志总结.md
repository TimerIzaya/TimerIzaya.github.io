---
layout:     post
title:      Mysql日志总结
subtitle:   备份合理，万无一失
date:       2021-12-5
author:     Timer
header-img: img/the-first.png
catalog: false
tags:
    - Mysql
    - 数据库

---

## BinLog

官方文档：https://dev.mysql.com/doc/refman/8.0/en/binary-log.html

binlog是server层维护的一种二进制逻辑日志，说白了就是记sql语句的。

主要作用有：

- **主从复制**：master开binlog，master把它的binlog给slave，用于slave和master同步数据。
- **数据恢复**：通过mysqlbinlog工具恢复数据，比如归档需要。

**查看其位置信息**

```
show variables like '%log_bin%';
```

**查看binlog文件列表**

```
show binary logs;
```

**查看当前状态，正在写的文件和写的位置**

```
show master status
```

**查看文件内容**

```
mysqlbinlog [file]
```

  



## BinLog 格式

```
show variables like 'binlog_format';
```

- Statememt level ：记录每一条修改数据的sql。**缺点是为了保障slave和master能同步，必须记录上下文信息，保证主从的一致性。**
- Row level ：仅仅保存被修改的部分。**缺点是以行的单位记录修改细节，因此内容会特别多，日志量很大。尤其当执行alter语句，整个表结构发生变化，那么每一条记录都会记录到日志，效率很低。**
- Mixed level：顾名思义。但是新版mysql对row也进行了优化，遇见表结构变更等非常冗余的部分会直接用statement来替代。



## BinLog主从部署

1. **给主服务器创建一个专门用来连接的账户，权限为replication slave。**

   ```
   grant replication slave on *.* to 'worker'@'ip' identified by 'passwd';
   flush privileges;
   ```

   去从服务器上登录一下看是否成功。  

   

2. **修改master的配置**

   ```
   server-id = 1　　　　　　　　//唯一id
   
   log-bin=mysql-bin           //指定日志文件
   
   binlog-do-db = test　　　　  //记录日志的数据库
   
   binlog-ignore-db = mysql    //不记录日志的数据库
   ```

   重启让配置生效即可。  

   然后查看master的状态，也就是当前用的binlog文件名，这个文件目前写入的位置，要和从库的位置同步。

   ```
   show master status
   ```

   

3. **修改slave配置**

   ```
   server-id = 2
   
   log-bin=mysql-bin
   
   replicate-do-db = xxx
   
   replicate-ignore-db = xxx
   ```

   重启让配置生效即可。    

   

4. **指定同步位置**

   ```mysql
   stop slave;
   
   change master to 
   master_host='master_ip',
   master_user='worker',
   master_password='passwd',
   master_log_file='mysql-bin.xxx',
   master_log_pos=xxx;
   
   start slave;
   ```

     

  

## Redo Log

事务保证一致性，也就是从一个状态转移到另一个状态，同时满足约束。

mysql保证一致性最简单的做法就是每次事务提交的时候，把事务中修改的部分全部刷到磁盘中，但这会有两个问题。

- InnoDB是以页为单位的，一页16K，而一个事务可能只修改几个字节，单独刷盘，浪费资源。
- 一个事务可能设计多个数据页，而且这些页在物理上并不连续，**随机IO性能总是弱于顺序IO的**。

redolog的核心就是WAL（Write-Ahead-Log），也就是先写日志，刷盘，这块是顺序IO。整个日志是环形的，当日志写满，则会把数据写入磁盘，腾出日志空间。

所以有了WAL，redo log就有了**crash safe**的能力，即便数据库发生了异常重启，之前提交的数据都不会丢失。

这里总结一下redo log和bin log的不同：

- redo是物理层的，也就是InnoDB特有的。而bin是服务层的，所以引擎都适用。
- redo是物理日志，记录的是在某个数据页做什么修改。而bin是逻辑日志，说白了就是记sql的原始逻辑，比如“给id为1的行的c字段+1”。
- redo是循环写的，空间固定可以用完；而bin是可以后续追加写的。















