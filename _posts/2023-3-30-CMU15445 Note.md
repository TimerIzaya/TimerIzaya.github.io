---
layout:     post
title:      CMU15-445 Note
subtitle:   
date:       2023-3-27
author:     Timer
header-img: img/the-first.png
catalog: false
tags:
    - Database
    - Note

---

# Buffer Pool

​	这段主要说明Page在内存中如何存储，与磁盘存储不同，内存存储涉及到了诸多读写、事务、日志操作，磁盘中存储page一般使用LSM或者B+Tree，而内存中一般直接使用HashMap。

​	如果单指存储的话，page在内存中则是紧凑的排在一起，可以理解为单位为4k的数组。这个数组称为**Buffer Pool**，里面的每个单位叫**Frame**，之所以不叫Page是为了做区分，计算机领域中概念模糊的词语太多。

​	实际上，不可能每次去内存里找个Page都要遍历Buffer Pool，这里用一个Map来做映射，Key为Page ID，Value为在Buffer Pool中的偏移。这个Map称为**Page Table**。

​	![image-20230330213043770](https://raw.githubusercontent.com/TimerIzaya/TimerBlogPic/master/image-20230330213043770.png)

​	PageTable的作用除了寻找内存中缓存的Page，同样也可以存Page相关的MetaData，用于跟踪当前Pool中的Page是什么状态。MetaData主要有两种：

- **Dirty Flag：**记录这个page是否被修改，改了就脏了，脏了就不能用了。
- **Pin Counter：**记录这个page当前有几个线程在查询，该count为0才能进行写操作。

​	可以看出，Dirty Flag保护读操作，Pin Counter保护写操作。想要使这两个MetaData生效，那必然需要锁，数据库中锁的概念分为Latch和Lock。Lock作用于表、数据库，Latch作用于内部数据结构、内存区域等等。

- **Locks**
  - 持续在整个事务过程中
  - 保证事务隔离
  - 支持事务回滚
- **Latchs**
  - 持续在单个操作过程中
  - 保护内部数据的线程安全
  - 不支持事务回滚

然而到目前为止只是概念上的Buffer Pool，实际上真的在内存中分配Buffer Pool的空间时，有两种策略。

- **Global Polices：**所有事务共享Buffer池
- **Local Polices：**一个事务对应一个Buffer池，不用考虑其他事务，但是需要支持共享page。

Buffer的基础非常简单，无非就是内存当跳板，内存有想要的page就拿，没有就去磁盘取，但实际实现并不简单，下面是四种细节。

1. **Multiple Buffer Pools**
2. **Pre-Fetching**
3. **Scan Sharing**
4. **Buffer Pool Bypass**















































































