---
layout:     post
title:      虚拟内存
subtitle:   操作系统，漫漫长路
date:       2021-9-18
author:     Timer
header-img: img/the-first.png
catalog: false
tags:
    - OS




---

## 虚拟内存

OS里非常重要的一个技术，它让程序认为自己拥有连续可用的内存，而实际上，它在物理内存中可能是零散、不规则的，甚至部分暂存在磁盘，在需要的时候进行交换。每个进程，访问的其实都是虚拟内存，虚拟内存再映射成物理内存。  

  

## 内存分配

一个直接的朴素想法是，将虚拟内存和物理内存地址一一对应映射。

实际的考虑一下，内存的访问单位是Byte，假设有一个32位的CPU，内存寻址的最大地址是2^32，需要四个字节来表示。一个Byte的映射包含了物理地址和虚拟地址，至少需要8个字节。那4G的内存条有1024 * 1024 * 1024 * 4 个Byte，光映射就得至少32G，那么直接映射必然不合理。  



## 段表

段表是一个历史包袱。

它的设计理念是：**程序是由若干个逻辑分段组成的，代码、堆、栈、数据四个部分，CPU只需要关心现在要存的数据放在哪个段的哪个部分即可。**

分段机制下的虚拟地址由两部分组成：**段选择子**和**段内偏移量**。说大白话就是段的地址和段内的地址。

![](https://gitee.com/timerizaya/timer-pic/raw/master/img/1632372601172.jpeg)

在Intel初代的8086CPU上，当时的CPU和寄存器只有16位，意味着内存地址最大也就是65536，极小的内存也就没必要复杂的内存管理，程序访问地址都是实际的物理地址。

后续计算器要求多任务，则用分段划分了内存。分段是从程序运行的角度，把ELF划分成一个个不同功能的单元。

The Linux Programming Interface这本书里谈到：

> **Linux uses segmentation in a very limited way**. In fact, segmentation and paging are somewhat redundant, because both can be used to separate the physical address spaces of processes: segmentation can assign a different linear address space to each process, while paging can map the same linear address space into different physical address spaces.
>
> Linux用分段是一种效果非常有限的划分方式。事实上，分段和分页都一定程度上重复了，因为两者都是为进程划分物理空间地址的方法。分段可以给每个进程分配不同的线性空间，但是分页可以把相同的线性地址空间映射到不同的物理地址空间。

事实上，现在Linux已经抛弃了分段，只有分页。  







## 页表

Byte对Byte这种映射是不行的，那么考虑N个Byte对N个Byte之间的映射关系，也就是虚拟内存的某个区域，映射到真实内存的某个区域。

这个区域OS一般设定为4K，也就是**页（Page）**。

假设内存为4G，则一共有 4 * 1024 * 1024 * 1024  **/**  4 * 1024 **=**  1M对映射，页表仅仅需要8M内存。











## 









































