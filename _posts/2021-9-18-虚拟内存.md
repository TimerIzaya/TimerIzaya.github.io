---
layout:     post
title:      虚拟内存
subtitle:   操作系统，漫漫长路
date:       2021-9-18
author:     Timer
header-img: img/the-first.png
catalog: false
tags:
    - OS




---

## 虚拟内存

OS里非常重要的一个技术，它让程序认为自己拥有连续可用的内存，而实际上，它在物理内存中可能是零散、不规则的，甚至部分暂存在磁盘，在需要的时候进行交换。每个进程，访问的其实都是虚拟内存，虚拟内存再映射成物理内存。  

  

## 内存分配

一个直接的朴素想法是，将虚拟内存和物理内存地址一一对应映射。

实际的考虑一下，内存的访问单位是Byte，假设有一个32位的CPU，内存寻址的最大地址是2^32，需要四个字节来表示。一个Byte的映射包含了物理地址和虚拟地址，至少需要8个字节。那4G的内存条有1024 * 1024 * 1024 * 4 个Byte，光映射就得至少32G，那么直接映射必然不合理。  



## 段表

段表是一个历史包袱。

它的设计理念是：**程序是由若干个逻辑分段组成的，代码、堆、栈、数据等等，CPU只需要关心现在要存的数据放在哪个段的哪个部分即可。**

分段机制下的虚拟地址由两部分组成：**段选择子**和**段内偏移量**。说大白话就是段的地址和段内的地址。

如图：

![](https://gitee.com/timerizaya/timer-pic/raw/master/img/1632372601172.jpeg)

在Intel初代的8086CPU上，当时的CPU和寄存器只有16位，意味着内存地址最大也就是65536，极小的内存也就没必要复杂的内存管理，程序访问地址都是实际的物理地址。

后续计算器要求多任务，则用分段划分了内存。有两个主要原因：

1. 分段方便重定位。（重定位指的是程序中调用其他指令，需要根据程序的基质重新定位这条指令的地址。比如当前程序在内存的地址属于10000~11000，在10800处有个指令调用了200地址的指令，那么这个200不能直接去物理地址找，要重定位成10200。）
2. 8086 CPU是20位，可寻址范围是1M。但是寄存器等等都是16位，通过段偏移可以扩大寻址范围。**也就是所谓的历史包袱**。

The Linux Programming Interface这本书里谈到：

> **Linux uses segmentation in a very limited way**. In fact, segmentation and paging are somewhat redundant, because both can be used to separate the physical address spaces of processes: segmentation can assign a different linear address space to each process, while paging can map the same linear address space into different physical address spaces.
>
> Linux用分段是一种效果非常有限的划分方式。事实上，分段和分页都一定程度上重复了，因为两者都是为进程划分物理空间地址的方法。分段可以给每个进程分配不同的线性空间，但是分页可以把相同的线性地址空间映射到不同的物理地址空间。

事实上，现在Linux已经抛弃了分段，只有分页。  

个人认为原因如下：

1. **复杂的内存管理。**分段没有统一的方案，比如有些情况程序占用大量符号表，其他段使用较少，那么则需要整体迁移。

2. **容易产生内存碎片**。一旦产生内存碎片，则需要使用交换机制（把不用的进程暂时放到硬盘，需要的时候再拿回）进行处理，效率很低。  

     

   

## 页表

Byte对Byte这种映射是不行的，那么考虑N个Byte对N个Byte之间的映射关系，也就是虚拟内存的某个区域，映射到真实内存的某个区域。

这个区域OS一般设定为4K，也就是**页（Page）**。

假设内存为4G，则一共有 4 * 1024 * 1024 * 1024  **/**  4 * 1024 **=**  1M对映射，页表仅仅需要8M内存。





 阿萨德





## 









































