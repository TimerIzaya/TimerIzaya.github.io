---
layout:     post
title:      拿下索引
subtitle:   进军数据库
date:       2021-11-19
author:     Timer
header-img: img/the-first.png
catalog: false
tags:
    - Mysql
    - 数据库

---

## 索引是什么

存储在磁盘中的一种数据结构，用于加速查询。典型的空间换时间。

## 索引的常见模型

1. ### 哈希表

   哈希表思路很明显，遇见冲突拉链即可。哈希表最大的问题在于key值的无序，无法做区间查询。

   所以**哈希表这种结构适用于只有等值查询的场景**，比如Memcached及其他一些NoSQL引擎。    

   

2. ### 有序数组

   有序数组思路更明显，比如对手机号码建立索引，那就把手机号码按序存储，查询用二分，**查区间**也可以二分。

   但它致命的问题在于增删的时候要挪动整个数组，原因同ArrayList。

   所以，**有序数组索引只适用于静态存储引擎**，比如要保存的是2021年中国的所有人口信息，这类不会再修改的数据。  

   

3. ### 二叉树

   1. #### BST（Binary Search Tree）

      优点很明显。问题也很多。

      首先是容易退化成线性链表。

      其次是硬件拖后腿，大多数数据库存储不用二叉树，而用N叉树，因为索引要持久化到磁盘。

      机械硬盘随机读一次往往要10w个时钟周期，大概10ms左右。如果现在有200w数据，层高32，那么访问一次可能要32*10 = 320ms左右，慢的离谱，和索引加速的需求背道而驰。而N叉树的话，如果这个N是1k，那么三层就足够存10亿个数了，查找一个值最多只要三次IO。

      回到二叉树，相比起IO的问题，二叉树最关键的问题在于不平衡。解决这个问题，基于节点的旋转和调整的有AVL和红黑树。

      

   2. #### 红黑树（Red-Black Tree）

      红黑树结构复杂，但它的操作有最好的最坏情况运行时间。它可以在O(log n)时间内完成增删改查。

      但其致命问题在于：如果数据顺序插入，那么树将形成一种**右倾**的状态，虽然没有链表那么夸张，但是也是相当的损耗。

      右倾如下(网图)：

      <img src="https://pic1.zhimg.com/80/v2-60cea4af963b156ee5f40030977ab77c_720w.jpg" alt="img" style="zoom: 67%;" />   

      

   3. #### AVL（Adelson-Velsky and Landis Tree）

      AVL则是完全平衡树，任意两子树高度差最大为1。和红黑树一样，可以在O(log n)时间内完成增删改查。

      但AVL依然不适合作为索引，理由就是上面说的IO问题。

      但是磁盘IO存在**4K对齐**的特性，这意味着取1B数据和4KB数据消耗的时间是一样的。根据这个思路，在一个树节点上存多个数据，一次IO多加载些数据，便可以充分利用IO的特性，这就是B树的设计原理。  

      

   4. #### B树（B-Tree）

      B树总来的来说就是说一个**一般化**的BST，但它一个节点可以拥有两个以上的子节点。也就是所谓的**多叉树**。

      根据作者的定义，一个m阶的B树是一个这样的树：

      - 每一个节点最多有m个子节点
      - 每一个非叶子节点最少有 m / 2 个子节点
      - 如果根节点不是叶子节点，那么它最少有 m / 2个子节点
      - 有k个子节点的非叶子节点有k - 1个键
      - 所有的叶子结点都在一层

      键的含义为：如果一个节点有三个子节点a、b、c，那么它必须有两个键k1、k2。

      a子树的所有值必须小于k1，b子树的所有值必须在k1、k2之间，c子树的值必须大于k2。也就是所谓的**多叉搜索树**。

      但B树依然依然依然有个问题，就是它存的是实际的数据，而不是数据的地址（索引）。而B+树解决了这个问题。  

      

   5. #### B+树（B+Tree）

      B+树第一点优化在于：节点存储的数据换成了数据地址，这意味着一个节点可以存储更多的数据，使整个树的高度降低，减少了IO次数。

      B+树第二点优化在于：B+树的同一层的叶子节点用一个链表相连，由于其本身节点之间就是有序的，所以整个链表也是有序的，方便范围查找。

     
   
   

## 索引的常见模型

### InnoDB 的索引模型

InnoBD表是根据主键顺序以索引的形式存放的，这种存储方式的表叫**索引组织表**。

InnoDB使用了B+树，所以所有数据都存在B+树里。

**每一个索引对应着一个B+树。**

以q_bind表为例（q_bind是若干年前流出的q绑数据，name和age是随机生成的假数据，一共1000w行）：

```mysql
CREATE TABLE `q_bind` (
  `id` int NOT NULL AUTO_INCREMENT,
  `phone` varchar(12) NOT NULL,
  `qq` varchar(12) NOT NULL,
  `name` varchar(20) DEFAULT NULL,
  `age` int DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `qq` (`qq`)
) ENGINE=InnoDB
```

索引可以分为主键索引和非主键索引。

主键索引的叶子节点，存的是整行数据，所以也叫聚簇索引（clustered index）。

非主键索引的叶子结点，存的是主键的值，所以也叫二级索引（secondary index）。

这两者最明显的区别在于：

```mysql
select * from q_bind where id = 123456;
```

这是主键查询，只需要搜索 id 对应的B+树即可。

```mysql
select * from q_bind where qq = '123456';
```

这里普通索引查询，要先搜索 qq 对应的B+树，得到qq对应的id值是10001（假设），那么根据这个10001再到 id 对应的B+树中再搜一次。

这个过程也叫“**回表**”。

精准查询中可能看不出明显差距，毕竟去聚簇索引查一次也就几十毫秒甚至几毫秒的时间，但是范围查询则非常明显。

比如以下这条sql语句：

```mysql
select phone from q_bind where age between 123 and 1234;
```

age列无索引，**106688 rows in set (10.66 sec)**

age列有索引，**106688 rows in set (20.25 sec)**

sql语句改成：

```mysql
select id from q_bind where age between 123 and 1234; #覆盖索引
```

age列有索引，**106688 rows in set (0.03 sec)**。

这慢的20s，几乎全是回表的时间，假设去主键的索引查一次只需要1ms，那么10w个结果集也要消耗将近10s。

**结论：**

在范围查询中，结果集过多，回表会极大的影响效率，**甚至不如不加索引**。所以，非主键索引需要多搜一棵树，应用中尽量用主键查询。



## 索引维护

索引维护的过程就是对索引增删的过程，也就是B+树的页分裂和合并的过程。

当对一个空间已满，且范围为100~200的页中插入150，那么这个页会进行分裂。

当一个页的空间利用率很低，那么同样会进行合并。

不管是分裂还是合并，都会降低性能。

**很多建表规范中都会要求主键自增**，当然不是绝对的。直观来看索引自增的情况就避免了分裂和合并，效率最高。

> 如果现在这个表中有身份证字段，是用身份证作为主键还是自增id作为主键？

由于非索引主键上的值是主键的值，意味着如果让身份证号作为主键的话，其他二级索引的每个值都要占用约20个字节。如果用自增id作为主键的话，那么身份证号作为二级索引，它的值只要4个字节。

**所以，主键长度越小，普通索引的叶子节点就越小，普通索引占的空间越小。**

所以，从性能和存储考虑，自增主键往往是最合理的选择。

但是有些业务场景比较特别，也就是KV场景：

- 只要一个索引
- 该索引是唯一索引

由于没有其他索引，也就不用考虑二级索引的值大小问题了。

这里引入一个实际案例：

```mysql
alter table q_bind drop index age;
alter table q_bind add index(age);
```

```mysql
alter table q_bind drop primary key;
alter table q_bind add primary key(id);
```

一个是重建K索引，一个是重建主键索引。很明显，重建K是合理的，因为索引可能因为删除或者增加导致页分裂，使内存有碎片，重建索引会按序插入，这样页面利用率最高。很明显，重建主键索引是不合理的，Innodb是索引组织表，重建索引相当于把整个表重建了。如果执行语句2，那么语句1就白做了。  



## 联合索引

假设现在有个高频的请求，根据age去查找phone，为了避免回表造成的性能损失，那么可以考虑建一个联合索引。

```mysql
alter table q_bind add index(age, phone);
```

这时候同样执行一条语句：

```mysql
select phone from q_bind where age between 123 and 1234;
```

联合索引前：**106688 rows in set (10.58 sec)**

联合索引后：**106688 rows in set (0.03 sec)**

这时候就建立了k和name的联合索引，联合索引的查询是根据**最左前缀原则**的.

比如创建了联合索引（col1,col2,col3)，那么索引会生效在(col1)，(col1,col2)，(col1,col2,col3)。

比如建立以下联合索引：

```mysql
alter table q_bind add index(age, phone, qq);
```

那么以下语句可以适用索引：

```mysql
select phone from q_bind where age between 123 and 1234; #有效
select qq, phone from q_bind where age between 123 and 1234; #有效
select id, qq, phone from q_bind where age between 123 and 1234; #有效
select * from q_bind where age = 123; #有效
select * from q_bind where phone = '123123'; #无效
select * from q_bind where qq = '123123'; #无效
```













