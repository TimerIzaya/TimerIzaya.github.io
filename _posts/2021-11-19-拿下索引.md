---
layout:     post
title:      拿下索引
subtitle:   进军数据库
date:       2021-11-19
author:     Timer
header-img: img/the-first.png
catalog: false
tags:
    - Mysql
    - 数据库

---

## 索引是什么

存储在磁盘中的一种数据结构，用于加速查询。典型的空间换时间。

## 索引的常见模型

1. ### 哈希表

   哈希表思路很明显，遇见冲突拉链即可。哈希表最大的问题在于key值的无序，无法做区间查询。

   所以**哈希表这种结构适用于只有等值查询的场景**，比如Memcached及其他一些NoSQL引擎。    

   

2. ### 有序数组

   有序数组思路更明显，比如对手机号码建立索引，那就把手机号码按序存储，查询用二分，**查区间**也可以二分。

   但它致命的问题在于增删的时候要挪动整个数组，原因同ArrayList。

   所以，**有序数组索引只适用于静态存储引擎**，比如要保存的是2021年中国的所有人口信息，这类不会再修改的数据。  

   

3. ### 二叉树

   1. #### BST（Binary Search Tree）

      优点很明显。问题也很多。

      首先是容易退化成线性链表。

      其次是硬件拖后腿，大多数数据库存储不用二叉树，而用N叉树，因为索引要持久化到磁盘。

      机械硬盘随机读一次往往要10w个时钟周期，大概10ms左右。如果现在有200w数据，层高32，那么访问一次可能要32*10 = 320ms左右，慢的离谱，和索引加速的需求背道而驰。而N叉树的话，如果这个N是1k，那么三层就足够存10亿个数了，查找一个值最多只要三次IO。

      回到二叉树，相比起IO的问题，二叉树最关键的问题在于不平衡。解决这个问题，基于节点的旋转和调整的有AVL和红黑树。

      

   2. #### 红黑树（Red-Black Tree）

      红黑树结构复杂，但它的操作有最好的最坏情况运行时间。它可以在O(log n)时间内完成增删改查。

      但其致命问题在于：如果数据顺序插入，那么树将形成一种**右倾**的状态，虽然没有链表那么夸张，但是也是相当的损耗。

      右倾如下(网图)：

      <img src="https://pic1.zhimg.com/80/v2-60cea4af963b156ee5f40030977ab77c_720w.jpg" alt="img" style="zoom: 67%;" />   

      

   3. #### AVL（Adelson-Velsky and Landis Tree）

      AVL则是完全平衡树，任意两子树高度差最大为1。和红黑树一样，可以在O(log n)时间内完成增删改查。

      但AVL依然不适合作为索引，理由就是上面说的IO问题。

      但是磁盘IO存在**4K对齐**的特性，这意味着取1B数据和4KB数据消耗的时间是一样的。根据这个思路，在一个树节点上存多个数据，一次IO多加载些数据，便可以充分利用IO的特性，这就是B树的设计原理。  

      

   4. #### B树（B-Tree）

      B树总来的来说就是说一个BST，但它一个节点可以拥有两个以上的子节点。

























