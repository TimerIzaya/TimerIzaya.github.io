---
layout:     post
title:      GC总结（待续）
subtitle:   Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。
date:       2021-10-2
author:     Timer
header-img: img/the-first.png
catalog: false
tags:
    - JVM





---

## 判断对象是否已死

GC作为垃圾回收器，回收是死掉的对象。所以在记录GC之前要先知道，什么样的对象叫死掉的对象。

- **引用计数法**

  给对象添加一个计数器，有一个引用就+1，引用失效就-1，为0就死。

  缺点：有很多例外情况需要考虑，比如循环引用，属于致命伤。

- **可达性分析法**

  以GC Roots为根，各个对象之间形成图状的**引用链**。如果某个对象没有根，那么就死了。

  GC Roots的定义：A garbage collection root is an object that is accessible from outside the heap。

  GC Roots有：

  - 所有已加载的类。
  - 所有线程栈帧的引用。就是通常意义的new
  - JVM内部的引用
  - JNI
  - **所有synchronized锁住的对象引用**
  - String常量池

  详情见：https://help.eclipse.org/latest/index.jsp?topic=%2Forg.eclipse.mat.ui.help%2Fconcepts%2Fgcroots.html&cp=37_2_3  
  
  

## 引用

​	可达性分析靠的就是图算法+引用链，在JAVA1.2之后，对引用的概念进一步的扩充，衍生出了四种引用。

​	个人觉得，JAVA比C虽然少了指针直接处理内存。但是有GC免于四处free，有了四大引用用来方便各种使用场景，从某种程度上来说也算解放劳动力了。

- **强引用。*

- 弱引用

  ​	只能活到下一次GC。 经典例子ThreadLocalMap中的Key值使用了弱引用，在无外部强引用的情况下，自动清除，防止内存泄漏。

- **软引用**

  ​	如果内存不够了，内存快不够的时候，GC直接杀掉软引用对象。适用于内存紧张的情况，典型的**缓存设计**。

  ​	**但是个人觉得**：软引用作为缓存是一种很牵强的方式，因为软引用会在内存使用量超过一定阈值的时候杀掉所有软引用，意味着当某一个值加入缓存池的时候刚好约过这个阈值的话，所有的缓存池都会被清空，这是一种效率很低的方式。同时，如果缓存使用的是map结构的话，value值使用了软引用，value被GC过后会造成空间泄漏，这个时候还要ReferenceQueue去检测软引用的情况，一一去除“脏”的键值对。可能某些极端场景需要，但总体有点感觉是为了用软引用而去用软引用。

  ​	附带一个自己加深理解写的软引用[缓存Demo](https://github.com/TimerIzaya/Demos/blob/master/src/com/timer/JVM/SoftReferenceCacheDemo.java)。

- 虚引用

  最弱的引用，无法通过虚引用获得实例，对其对象的生存时间也毫无影响。唯一作用在于能在这个对象被回收时收到一个系统通知。






## 垃圾回收算法

- #### 标记-清除

  - 缺点1：执行效率不稳定，需要回收的对象越多，效率越低。
  - 缺点2：容易产生内存碎片，致使大对象找不到连续内存继续触发GC。

- #### 标记-复制

  ​	**新生代对象，死亡率很高，所以采用复制算法，成本低，效率高。**

  - **方法1：半区复制**

    可用内存分为两半，每次只用其中的一半，如果一块用完了，就把活着的对象复制到另一半，再把刚刚那一半给清除了。这种方法实现方便，效率也高，最大的缺点在于可用空间变为二分之一。

  - **方法2：Apple式回收（Apple是作者名）**

    IBM有一项研究表明新生代的对象98%都熬不过第一轮回收。

    基于这个前提，将内存分为一块eden区和两块survivor区，空间比例为8:1:1。每次只使用eden区和一块survivor区，当GC时，把活着的对象放到另一块survivor区中，和半区复制如出一辙。如果活着的对象数量超过了survivor区的容量时，就会把这个对象放到老年代里。

- #### 标记-整理

  ​	**老年代**的对象一般比较大，用复制算法效率低，空间也浪费，所以用整理算法，将其全部挪到一边。





## 一些垃圾回收细节：

- #### **根节点枚举**

  ​		垃圾回收首先得找到所有的GC Roots，也就是根节点枚举。

  ​		GC Roots宽泛来说分为全局性的引用，比如常量池或者类的静态属性，或者就是局部的引用，比如栈帧中的局部变量表。逐个遍历内存必然不可行，因为定位各个根节点这个过程是必须STW的，必须保证各个根节点的引用关系不能发生变化。STW的时间必须要短，不然用户体验很差。所以这里采用了空间换时间的思路，JVM设计了一个OopMap的数据结构，当类加载完成，就会把各个对象的各个成员变量的偏移值记录下来存在这个Map中。

- ### **安全点**

  因为程序中的各个引用是动态的，如果所有时刻都保持记录和更新的话，上面引入的OopMap，直接使用的话带来的空间消费是极其高昂的。

  理一下逻辑，根节点枚举是了GC，所以只要在GC之前更新即可。所以有了安全点这个设定，当指令流到达安全点的时候，先更新oopmap，再进行GC。由此也可见，GC不是任意时刻都可以进行的，程序中调用System.gc()，也不是立刻就能执行。

  安全点的选取也是有讲究的，如果安全点太少，那么gc等待的时间就会长，如果安全点太多，又会降低性能。

  一般选取在如下几个位置：

  - 循环的末尾

  - 方法返回之前

  - 调用方法之后

  - 抛异常的位置

- #### **如何让当前所有线程都达到安全点**

    目前主要使用的是主动式中断，不直接让各个线程中断，给它一个标志位，线程执行的过程中会不断轮询这个标志位。如果标志位为真，则在附近最近的安全点主动挂起。

- #### **安全区域**

  安全区域就是指某一段代码中，引用关系不会发生变化。比如Sleep语句，Wait阻塞等等，这里可以看成全部都是安全点，可以随意进行GC。

​		



## 新生代回收器：

### Serial

单线程，收集的时候必STW。标记-复制算法。

### ParalLel scavenge

Serial的多线程版本。最主要的特点在于他的关注点是尽可能的缩短STW时间，提高吞吐量，吞吐量为 **代码运行时间 / 处理器总耗时**。主要适合后台计算而不需要太多用户交互的情况。

### ParNew

Serial的多线程版本。其最大的意义在于，只有它能和CMS配合工作。ParalLel scavenge包括G1当初设计的时候都没有用HotSpot的分代框架，而是独立的一部分。

## 老年代回收器

### Serial Old

单线程，收集的时候必STW。标记-整理算法。

与Serial配合运行示意图：

<img src="https://gitee.com/timerizaya/timer-pic/raw/master/img/20211020200336.png" style="zoom:67%;" />

### Parallel Old

是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。在此之前，Parallel Scavenge没有与之配合的老年代收集器，只能勉强用Serial Old。Parallel Old出现后，对于吞吐量优先或者处理器资源稀缺的情况，就有了一对很好的组合。

与Parallel Scavenge配合运行示意图：

<img src="https://gitee.com/timerizaya/timer-pic/raw/master/img/20211020200315.png" style="zoom:67%;" />



### CMS(Concurrent  Mark  Sweep)

主要目标是获取最短回收停顿的时间，也就是让STW尽可能短的GC。适用于对响应速度要求很高的WEB服务。

CMS是老年代收集器中少见的以**标记-清除**算法作为理论基础的GC。主要有以下四个步骤：

1. 初始标记（CMS initial mark） **(STW)** ：标记一下GC Roots能直接关联到的对象。
2. 并发标记（CMS concurrent mark） ： 遍历整个对象图，和用户线程同时执行。
3. 重新标记（CMS remark） **(STW)** ： 修正并发标记时，用户程序导致标记发生变动的对象。这里涉及到增量更新，需要重点理解。
4. 并发清除（CMS concurrent sweep） ： 清除标记好的对象。

可见，CMS的优点在于：**并发收集、低停顿**

但是缺点也很明显：

- 并发收集，资源敏感。默认回收线程数是（core + 3) / 4，对于低于4核的情况不友好。
- 无法处理浮动垃圾。
- 标记-清除带来的内存碎片。可以调整JVM参数整理碎片。













