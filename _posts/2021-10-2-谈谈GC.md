---
layout:     post
title:      GC总结（待续）
subtitle:   Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。
date:       2021-10-2
author:     Timer
header-img: img/the-first.png
catalog: false
tags:
    - JVM





---

## 判断对象是否已死

GC作为垃圾回收器，回收是死掉的对象。所以在记录GC之前要先知道，什么样的对象叫死掉的对象。

- **引用计数法**

  给对象添加一个计数器，有一个引用就+1，引用失效就-1，为0就死。

  缺点：有很多例外情况需要考虑，比如循环引用，属于致命伤。

- **可达性分析法**

  以GC Roots为根，各个对象之间形成图状的**引用链**。如果某个对象没有根，那么就死了。

  GC Roots的定义：A garbage collection root is an object that is accessible from outside the heap。

  GC Roots有：

  - 所有已加载的类。
  - 所有线程栈帧的引用。就是通常意义的new
  - JVM内部的引用
  - JNI
  - **所有synchronized锁住的对象引用**
  - String常量池

  详情见：https://help.eclipse.org/latest/index.jsp?topic=%2Forg.eclipse.mat.ui.help%2Fconcepts%2Fgcroots.html&cp=37_2_3  
  
  

## 引用

​	可达性分析靠的就是图算法+引用链，在JAVA1.2之后，对引用的概念进一步的扩充，衍生出了四种引用。

​	个人觉得，JAVA比C虽然少了指针直接处理内存。但是有GC免于四处free，有了四大引用用来方便各种使用场景，从某种程度上来说也算解放劳动力了。

- **强引用。*

- 弱引用

  ​	只能活到下一次GC。 经典例子ThreadLocalMap中的Key值使用了弱引用，在无外部强引用的情况下，自动清除，防止内存泄漏。

- **软引用**

  ​	如果内存不够了，内存快不够的时候，GC直接杀掉软引用对象。适用于内存紧张的情况，典型的**缓存设计**。

  ​	**但是个人觉得**：软引用作为缓存是一种很牵强的方式，因为软引用会在内存使用量超过一定阈值的时候杀掉所有软引用，意味着当某一个值加入缓存池的时候刚好约过这个阈值的话，所有的缓存池都会被清空，这是一种效率很低的方式。同时，如果缓存使用的是map结构的话，value值使用了软引用，value被GC过后会造成空间泄漏，这个时候还要ReferenceQueue去检测软引用的情况，一一去除“脏”的键值对。可能某些极端场景需要，但总体有点感觉是为了用软引用而去用软引用。

  ​	附带一个自己加深理解写的软引用[缓存Demo](https://github.com/TimerIzaya/Demos/blob/master/src/com/timer/JVM/SoftReferenceCacheDemo.java)。

- 虚引用

  最弱的引用，无法通过虚引用获得实例，对其对象的生存时间也毫无影响。唯一作用在于能在这个对象被回收时收到一个系统通知。






## 垃圾回收算法

- #### 标记-清除

  - 缺点1：执行效率不稳定，需要回收的对象越多，效率越低。
  - 缺点2：容易产生内存碎片，致使大对象找不到连续内存继续触发GC。

- #### 标记-复制

  ​	**新生代对象，死亡率很高，所以采用复制算法，成本低，效率高。**

  - **方法1：半区复制**

    可用内存分为两半，每次只用其中的一半，如果一块用完了，就把活着的对象复制到另一半，再把刚刚那一半给清除了。这种方法实现方便，效率也高，最大的缺点在于可用空间变为二分之一。

  - **方法2：Apple式回收（Apple是作者名）**

    IBM有一项研究表明新生代的对象98%都熬不过第一轮回收。

    基于这个前提，将内存分为一块eden区和两块survivor区，空间比例为8:1:1。每次只使用eden区和一块survivor区，当GC时，把活着的对象放到另一块survivor区中，和半区复制如出一辙。如果活着的对象数量超过了survivor区的容量时，就会把这个对象放到老年代里。

- #### 标记-整理

  ​	**老年代**的对象一般比较大，用复制算法效率低，空间也浪费，所以用整理算法，将其全部挪到一边。





## 一些垃圾回收细节：

- #### **根节点枚举**

  ​		垃圾回收首先得找到所有的GC Roots。

  ​		**准确式GC的“准确”体现在：当给定某个区域的某块数据的时候，这块数据到底是不是指针。**准确式GC要求jvm必须清楚的知道内存中哪些位置存放了对象引用。

  ​		因此HotSpot在外部用一数据结构来记录对象引用的位置，这个数据结构也就是OopMap。  

  

- ### **安全点**

  ​		程序运行期间，很多指令都是有可能修改引用关系的，即要修改OopMap。如果碰到就修改，那代价也太大了，故而引入了 SafePoint，只在 SafePoint 才会对 OopMap 做一个统一的更新。这也使得，只有 SafePoint 处 OopMap 是一定准确的，因此只能在 SafePoint 处进行 GC 行为。

  ​		**由此也可见，GC不是任意时刻都可以进行的，程序中调用System.gc()，需要跑到最近的安全点再执行，不是立刻就能执行**。

  ​		安全点的选取也是有讲究的，如果安全点太少，那么gc等待的时间就会长，如果安全点太多，又会降低性能。

  ​		一般选取在：循环的末尾、调用方法之后、方法返回之前、抛异常的位置 。  

  

- #### **如何让当前所有线程都达到安全点**

    目前主要使用的是主动式中断，不直接让各个线程中断，给它一个标志位，线程执行的过程中会不断轮询这个标志位。如果标志位为真，则在附近最近的安全点主动挂起。  

    

- #### **安全区域**

  安全区域就是指某一段代码中，引用关系不会发生变化。比如Sleep语句，Wait阻塞等等，这里可以看成全部都是安全点，可以随意进行GC。

- ### 跨代引用问题

  记忆集：记录从非收集区到收集区的指针集合，这是一种抽象的数据结构。

  卡表：记忆集的一种实现，这东西本质就是为了减少扫描old区域的范围。

  <img src="https://img-blog.csdnimg.cn/20181206235754987.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p5eG11c3Q=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 15%;align:left" />

    

    
  
  

## 新生代回收器：

### Serial

单线程，收集的时候必STW。标记-复制算法。

### ParalLel scavenge

Serial的多线程版本。最主要的特点在于他的关注点是尽可能的缩短STW时间，提高吞吐量，吞吐量为 **代码运行时间 / 处理器总耗时**。主要适合后台计算而不需要太多用户交互的情况。

### ParNew

Serial的多线程版本。其最大的意义在于，只有它能和CMS配合工作。ParalLel scavenge包括G1当初设计的时候都没有用HotSpot的分代框架，而是独立的一部分。

  



## 老年代回收器

### Serial Old

单线程，收集的时候必STW。标记-整理算法。

与Serial配合运行示意图：

<img src="https://gitee.com/timerizaya/timer-pic/raw/master/img/20211020200336.png" style="zoom:67%;" />

### Parallel Old

是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。在此之前，Parallel Scavenge没有与之配合的老年代收集器，只能勉强用Serial Old。Parallel Old出现后，对于吞吐量优先或者处理器资源稀缺的情况，就有了一对很好的组合。

与Parallel Scavenge配合运行示意图：

<img src="https://gitee.com/timerizaya/timer-pic/raw/master/img/20211020200315.png" style="zoom:67%;" />



### CMS(Concurrent  Mark  Sweep)

主要目标是获取最短回收停顿的时间，也就是让STW尽可能短的GC。适用于对响应速度要求很高的WEB服务。

CMS是老年代收集器中少见的以**标记-清除**算法作为理论基础的GC。主要有以下四个步骤：

1. 初始标记（CMS initial mark） **(STW)** ：标记一下GC Roots能直接关联到的对象。
2. 并发标记（CMS concurrent mark） ： 遍历整个对象图，和用户线程同时执行。
3. 重新标记（CMS remark） **(STW)** ： 修正并发标记时，用户程序导致标记发生变动的对象。这里涉及到增量更新，需要重点理解。
4. 并发清除（CMS concurrent sweep） ： 清除标记好的对象。

可见，CMS的优点在于：**并发收集、低停顿**

但是缺点也很明显：

- 并发收集，资源敏感。默认回收线程数是（core + 3) / 4，对于低于4核的情况不友好。
- 无法处理浮动垃圾。
- 标记-清除带来的内存碎片。可以调整JVM参数整理碎片。

  

  



## 全能选手- G1

JDK9的默认GC，同时CMS已经被警告未来会被抛弃。

作为CMS的继承者，G1的目的是Pause Prediction Model，也就是尽力达到在预期时间内GC完。

最显著的，它的垃圾回收范围有了变化。G1之前的所有GC目标范围要么是Minor GC，要么是Major GC，要么是Full GC。

而G1则面向全堆进行回收，衡量的标准从分代变成了哪块内存垃圾多，收益大，就回收哪个。这就是G1的Mixed GC模式。

和虚拟内存从分段到分页类似，GC从G1开始，不再大规模划分空间，而是以Region为基本单位，一个Region可以代表E S O，如果一个对象的大小超过1/2的Region Size的话，就会放入Humongous区域。

G1之所以能够Pause Prediction，是因为它以Region为回收单位，这样可以避免全堆一起收集。同时，给所有的Region以其价值进行排序，在期望时间内优先处理高价值的Region。

### G1的跨Region引用问题：

一个Region存一个记忆集，这种记忆集的实现本质上是一种哈希表，Key是其他Region的地址，Value是卡页的索引号。这也意味着G1要占用更多的空间。

### G1的垃圾回收阶段：

- **Young Collection(STW)** :  当E区达到阈值了，Young Collection 触发，把幸存对象复制到S区。当S区也达到阈值，再次触发，将够年龄的复制到O区，不够年龄的继续复制到新的S区。

- **Young Collection + CM** : 当O区达到阈值，会进行**并发**标记，决定哪些老年代要回收。

  1. **初始标记(STW）**：标记GC Roots
  2. 并发标记：并发的可达性分析，图扫描完还得重新处理SATB变动的部分。
  3. **最终标记(STW）**：清空SATB缓冲区。
  4. **筛选回收(STW）**：排序各个Region的价值和成本，选择要回收的Region。这里涉及到对象的移动，必须STW。

- **Mixed Collection** :  把选择的老年代区域和E S 区一起作为集合回收。

  
