---
layout:     post
title:      GC总结
subtitle:   Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。
date:       2021-10-2
author:     Timer
header-img: img/the-first.png
catalog: false
tags:
    - JVM





---

## 对象已死？

GC作为垃圾回收器，回收是死掉的对象。所以在记录GC之前要先知道，什么样的对象叫死掉的对象。

- **引用计数法**

  给对象添加一个计数器，有一个引用就+1，引用失效就-1，为0就死。

  缺点：有很多例外情况需要考虑，比如循环引用，属于致命伤。

- **可达性分析法**

  以GC Roots为根，各个对象之间形成图状的**引用链**。如果某个对象没有根，那么就死了。

  GC Roots的定义：A garbage collection root is an object that is accessible from outside the heap。

  GC Roots有：

  - 所有已加载的类。
  - 所有线程栈帧的引用。就是通常意义的new
  - JVM内部的引用
  - JNI
  - **所有synchronized锁住的对象引用**
  - String常量池

  详情见：https://help.eclipse.org/latest/index.jsp?topic=%2Forg.eclipse.mat.ui.help%2Fconcepts%2Fgcroots.html&cp=37_2_3  
  
  

## 引用

​	可达性分析靠的就是图算法+引用链，在JAVA1.2之后，对引用的概念进一步的扩充，衍生出了四种引用。

​	个人觉得，JAVA比C虽然少了指针直接处理内存。但是有GC免于四处free，有了四大引用用来方便各种使用场景，从某种程度上来说也算解放劳动力了。

- 强引用。

- 弱引用。

  ​	只能活到下一次GC。 经典例子ThreadLocalMap中的Key值使用了弱引用，在无外部强引用的情况下，自动清除，防止内存泄漏。

- 软引用。

  ​	如果内存不够了，内存快不够的时候，GC直接杀掉软引用对象。适用于内存紧张的情况，典型的**缓存设计**。

  ​	**但是个人觉得**：软引用作为缓存是一种很牵强的方式，因为软引用会在内存使用量超过一定阈值的时候杀掉所有软引用，意味着当某一个值加入缓存池的时候刚好约过这个阈值的话，所有的缓存池都会被清空，这是一种效率很低的方式。同时，如果缓存使用的是map结构的话，value值使用了软引用，value被GC过后会造成空间泄漏，这个时候还要ReferenceQueue去检测软引用的情况，一一去除“脏”的键值对。可能某些极端场景需要，但总体有点感觉是为了用软引用而去用软引用，LRU之类缓存的方式合情合理，不明白为什么面试中会有面试官问这种无聊的问题。

  ​	附带一个自己加深理解写的软引用[设计缓存Demo](https://github.com/TimerIzaya/Demos/blob/master/src/com/timer/JVM/SoftReferenceCacheDemo.java)。

- 虚引用。

  最弱的引用，无法通过虚引用获得实例，对其对象的生存时间也毫无影响。唯一作用在于能在这个对象被回收时收到一个系统通知。

  

## 垃圾回收算法

- #### 标记-清除

  - 缺点1：执行效率不稳定，需要回收的对象越多，效率越低。
  - 缺点2：容易产生内存碎片，致使大对象找不到连续内存继续触发GC。

- #### 标记-复制

  - **方法1：半区复制**

    可用内存分为两半，每次只用其中的一半，如果一块用完了，就把活着的对象复制到另一半，再把刚刚那一半给清除了。这种方法实现方便，效率也高，最大的缺点在于可用空间变为二分之一。

  - **方法2：Apple式回收（Apple是作者名）**

    IBM有一项研究表明新生代的对象98%都熬不过第一轮回收。

    基于这个前提，将内存分为一块eden区和两块survivor区，空间比例为8:1:1。每次只使用eden区和一块survivor区，当GC时，把活着的对象放到另一块survivor区中，和半区复制如出一辙。如果活着的对象数量超过了survivor区的容量时，就会把这个对象放到老年代里。

- #### 标记-整理

  和标记-清除的区别在于清除后会不会全部移动到另一端。

























