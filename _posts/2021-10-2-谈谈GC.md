---
layout:     post
title:      GC总结
subtitle:   Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。
date:       2021-9-18
author:     Timer
header-img: img/the-first.png
catalog: false
tags:
    - JVM





---

## 对象已死？

GC作为垃圾回收器，回收是死掉的对象。所以在记录GC之前要先知道，什么样的对象叫死掉的对象。

- **引用计数法**

  给对象添加一个计数器，有一个引用就+1，引用失效就-1，为0就死。

  缺点：有很多例外情况需要考虑，比如循环引用，属于致命伤。

- **可达性分析法**

  以GC Roots为根，各个对象之间形成图状的**引用链**。如果某个对象没有根，那么就死了。

  GC Roots的定义：A garbage collection root is an object that is accessible from outside the heap。

  GC Roots有：

  - 所有已加载的类。
  - 所有线程栈帧的引用。就是通常意义的new
  - JVM内部的引用
  - JNI
  - **所有synchronized锁住的对象引用**
  - String常量池

  详情见：https://help.eclipse.org/latest/index.jsp?topic=%2Forg.eclipse.mat.ui.help%2Fconcepts%2Fgcroots.html&cp=37_2_3
  

##   

## 引用

​	可达性分析靠的就是图算法+引用链，在JAVA1.2之后，对引用的概念进一步的扩充，衍生出了四种引用。

​	个人觉得，JAVA比C虽然少了指针直接处理内存。但是有GC免于四处free，有了四大引用用来方便各种使用场景，从某种程度上来说也算解放劳动力了。

- 强引用。

- 弱引用。

  ​	只能活到下一次GC。 经典例子ThreadLocalMap中的Key值使用了弱引用，在无外部强引用的情况下，自动清除，防止内存泄漏。

- 软引用。

  ​	如果内存不够了，内存快不够的时候，GC直接杀掉软引用对象。适用于内存紧张的情况，典型的缓存设计。

- 虚引用。



























