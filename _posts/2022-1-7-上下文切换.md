---
layout:     post
title:      到底什么是上下文切换
subtitle:   常挂嘴边，细问懵逼，现在补补，为时不晚
date:       2022-1-5
author:     Timer
header-img: img/the-first.png
catalog: false
tags:
    - OS


---

## CPU上下文切换

在每个任务运行前，CPU 都需要知道任务从哪里加载、又从哪里开始运行，也就是说，需要系统事先帮它设置好 **CPU 寄存器和程序计数器**。它们都是 CPU 在运行任何任务前，必须的依赖环境，因此也被叫做 **CPU 上下文**。

CPU 上下文切换，就是先把前一个任务的 CPU 上下文（也就是 CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。

OS的任务，主要分为进程和线程，以及中断处理程序。

所以，根据任务的不同，CPU 的上下文切换就可以分为几个不同的场景，也就是**进程上下文切换**、**线程上下文切换**以及**中断上下文切换**。



## 进程上下文切换

进程是由内核来管理和调度的，进程的切换只能发生在内核态。所以，进程的上下文不仅包括了虚拟内存、栈、全局变量等用户空间的资源（也就是PCB，具体见上面的博客），还包括了内核堆栈、寄存器等内核空间的状态。

显然，进程切换时才需要切换上下文，换句话说，只有在进程调度的时候，才需要切换上下文。

进程调度到 CPU的时机：

1. 某个进程的**时间片耗尽**了，就会被系统挂起，切换到其它正在等待 CPU 的进程运行。
2.  进程在**系统资源不足**（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行。
3. 当进程通过**睡眠函数** sleep 这样的方法将自己主动挂起时，也会重新调度。
4. 当有**优先级更高的进程**运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行。
5. 发生**硬件中断**时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序。  

  



## 线程上下文切换

线程与进程最大的区别在于，**线程是调度的基本单位，而进程则是资源拥有的基本单位**。说白了，所谓内核中的任务调度，实际上的调度对象是线程；而进程只是给线程提供了虚拟内存、全局变量等资源。

所以可以得出：

- 当进程**只有一个线程**时，可以认为进程就等于线程。
- 当进程**拥有多个线程**时，这些线程会**共享相同的虚拟内存和全局变量等资源**。这些资源在上下文切换时是不需要修改的。
- 另外，线程也有自己的**私有数据**，比如**栈和寄存器**等，这些在上下文切换时也是需要保存的。

所以线程的上下文切换也就两种情况：

- 前后两个线程属于不同进程。此时，因为资源不共享，所以切换过程就跟进程上下文切换是一样。
- 前后两个线程属于同一个进程。因为PCB是共享的，只需要切换线程的**栈、寄存器**等不共享的数据。

同为上下文切换，但同进程内的线程切换，要比多进程间的切换消耗更少的资源，而这，也正是多线程代替多进程的一个优势。

  

## **中断上下文切换**

为了快速响应硬件的事件，**中断处理会打断进程的正常调度和执行**，转而调用中断处理程序。

而在打断其他进程时，就**需要将进程当前的状态保存下来**，这样在中断结束后，进程仍然可以从原来的状态恢复运行。

跟进程上下文不同，中断上下文切换并不涉及到进程的用户态。所以，即便中断过程打断了一个正处在用户态的进程，也不需要保存和恢复这个进程的PCB。中断上下文，其实只包括内核态中断服务程序执行所必需的状态，包括 **CPU 寄存器、内核堆栈、硬件中断参数等**。

**对同一个 CPU 来说，中断处理比进程拥有更高的优先级**，所以中断上下文切换并不会与进程上下文切换同时发生。同样道理，由于中断会打断正常进程的调度和执行，所以大部分中断处理程序都短小精悍，以便尽可能快的执行结束。

  

## 总结

上下文就是切换，切换是针对任务而言的，执行任务是必须要CPU的，CPU的上下文切换需要程序计数器和寄存器。

而任务主要分为三种，进程、线程和中断。

进程说白了就是在切换的时候要更新PCB。

线程说白了，由于PCB是进程共有，需要切换线程私有数据，比如栈等等。

中断说白了，是进程中发生的，所以必然会导致进程上下文切换。







