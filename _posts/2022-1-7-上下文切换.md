---
layout:     post
title:      到底什么是上下文切换？
subtitle:   
date:       2022-1-5
author:     Timer
header-img: img/the-first.png
catalog: false
tags:
    - OS


---

[TOC]



## CPU上下文切换

在每个任务运行前，CPU 都需要知道任务从哪里加载、又从哪里开始运行，也就是说，需要系统事先帮它设置好 **CPU 寄存器和程序计数器**。它们都是 CPU 在运行任何任务前，必须的依赖环境，因此也被叫做 **CPU 上下文**。

CPU 上下文切换，就是先把前一个任务的 CPU 上下文（也就是 CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。

OS的任务，主要分为进程和线程，以及中断处理程序。

所以，根据任务的不同，CPU 的上下文切换就可以分为几个不同的场景，也就是**进程上下文切换**、**线程上下文切换**以及**中断上下文切换**。



## 进程上下文切换

进程是由内核来管理和调度的，进程的切换只能发生在内核态。所以，进程的上下文不仅包括了虚拟内存、栈、全局变量等用户空间的资源（也就是PCB，具体见上面的博客），还包括了内核堆栈、寄存器等内核空间的状态。

显然，进程切换时才需要切换上下文，换句话说，只有在进程调度的时候，才需要切换上下文。

进程调度到 CPU的时机：

1. 某个进程的**时间片耗尽**了，就会被系统挂起，切换到其它正在等待 CPU 的进程运行。
2.  进程在**系统资源不足**（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行。
3. 当进程通过**睡眠函数** sleep 这样的方法将自己主动挂起时，也会重新调度。
4. 当有**优先级更高的进程**运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行。
5. 发生**硬件中断**时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序。  

  



## 线程上下文切换

线程与进程最大的区别在于，**线程是调度的基本单位，而进程则是资源拥有的基本单位**。说白了，所谓内核中的任务调度，实际上的调度对象是线程；而进程只是给线程提供了虚拟内存、全局变量等资源。

所以可以得出：

- 当进程**只有一个线程**时，可以认为进程就等于线程。
- 当进程**拥有多个线程**时，这些线程会**共享相同的虚拟内存和全局变量等资源**。这些资源在上下文切换时是不需要修改的。
- 另外，线程也有自己的**私有数据**，比如**栈和寄存器**等，这些在上下文切换时也是需要保存的。

所以线程的上下文切换也就两种情况：

- 前后两个线程属于不同进程。此时，因为资源不共享，所以切换过程就跟进程上下文切换是一样。
- 前后两个线程属于同一个进程。因为PCB是共享的，只需要切换线程的**栈、寄存器**等不共享的数据。

同为上下文切换，但同进程内的线程切换，要比多进程间的切换消耗更少的资源，而这，也正是多线程代替多进程的一个优势。

  

## **中断上下文切换**

为了快速响应硬件的事件，**中断处理会打断进程的正常调度和执行**，转而调用中断处理程序。

而在打断其他进程时，就**需要将进程当前的状态保存下来**，这样在中断结束后，进程仍然可以从原来的状态恢复运行。

跟进程上下文不同，中断上下文切换并不涉及到进程的用户态。所以，即便中断过程打断了一个正处在用户态的进程，也不需要保存和恢复这个进程的PCB。中断上下文，其实只包括内核态中断服务程序执行所必需的状态，包括 **CPU 寄存器、内核堆栈、硬件中断参数等**。

**对同一个 CPU 来说，中断处理比进程拥有更高的优先级**，所以中断上下文切换并不会与进程上下文切换同时发生。同样道理，由于中断会打断正常进程的调度和执行，所以大部分中断处理程序都短小精悍，以便尽可能快的执行结束。

  

## 总结

上下文就是切换，切换是针对任务而言的，执行任务是必须要CPU的，CPU的上下文切换需要程序计数器和寄存器。

而任务主要分为三种，进程、线程和中断。

进程说白了就是在切换的时候要更新PCB。

线程说白了，由于PCB是进程共有，需要切换线程私有数据，比如栈等等。

中断说白了，是进程中发生的，所以必然会导致进程上下文切换。



## 实际应用

#### 前言

之前在打天池比赛的时候，因为Java不自带绑核操作，也不给用JNI，所以不可避免的会导致上下文切换，但是对具体什么量级的上下文切换心里没数，也不知道到底是不是个优化的点，心里总是很迷茫，现在用实际工具来测一下上下文切换。

### sysbench

sysbench 是一个多线程的基准测试工具，一般用来评估不同系统参数下的数据库负载情况。这里用来模拟上下文切换过多的问题。

```shell
1 # 以 10 个线程运行 5 分钟的基准测试，模拟多线程切换的问题
2 $ sysbench --threads=10 --max-time=300 threads run
```

### vmstat

vmstat 是一个常用的系统性能分析工具，主要用来分析系统的内存使用情况，也常用来分析 CPU 上下文切换和中断的次数。

```shell
1 # 每隔 5 秒输出 1 组数据
2 $ vmstat 5
```

结合sysbench，输出为

![image-20220107203058846](https://gitee.com/timerizaya/timer-pic/raw/master/img/image-20220107203058846.png) 

- cs（context switch）是每秒上下文切换的次数。

- in（interrupt）则是每秒中断的次数。

- r（Running or Runnable）是就绪队列的长度，也就是正在运行和等待 CPU 的进程数。

- b（Blocked）则是处于不可中断睡眠状态的进程数。

可以看出，上下文切换次数达到了百万级别，中断次数上千，就绪队列也在10以内。

但是，**vmstat** 只给出了**系统总体的上下文切换情况**，要想查看每个进程的详细情况，就需要使用我们前面提到过的 **pidstat** 了。

### pidstat

pidstat 是一个常用的进程性能分析工具，用来实时查看**进程**的 CPU、内存、I/O 以及上下文切换等性能指标。

```
1 # w 参数表示输出进程切换指标，而 -u 参数则表示输出 CPU 使用指标
2 $ pidstat -w -u 5
```

对应输出为：

![image-20220107203751411](https://gitee.com/timerizaya/timer-pic/raw/master/img/image-20220107203751411.png) 

- **cswch：voluntary context switches**

  自愿上下文切换，指进程无法获取所需资源，导致的上下文切换。比如说， I/O、内存等系统资源不足时，就会发生自愿上下文切换。

- **nvcswch：non voluntary context switches**

  非自愿上下文切换，则是指进程由于时间片已到等原因，被系统强制调度，进而发生的上下文切换。比如说，大量进程都在争抢 CPU 时，就容易发生非自愿上下文切换。

可以发现，CPU 使用率的升高是 sysbench 导致的，它的 CPU 使用率已经达到了 100%。但是这里的cswch是进程上下文，才几十，刚刚上百万的次数是加上线程的，具体可以使用 `pidstat -w -u -t 5` 查看。

### 查看中断

中断只发生在内核态，而 pidstat 只是一个进程的性能分析工具，并不提供任何关于中断的详细信息。

中断只能从 /proc/interrupts 这个只读文件中读取。/proc 实际上是 Linux 的一个虚拟文件系统，用于内核空间与用户空间之间的通信。/proc/interrupts 就是这种通信机制的一部分，提供了一个只读的中断使用情况。

```shell
 # -d 参数表示高亮显示变化的区域
2 $ watch -d cat /proc/interrupts
```

对应输出：

<img src="https://gitee.com/timerizaya/timer-pic/raw/master/img/image-20220107204221495.png" alt="image-20220107204221495" style="zoom:67%;" /> 

其中变化速度最快的是**重调度中断**（RES），这个中断类型表示，唤醒空闲状态的 CPU 来调度新的任务运行。

所以，这里的中断升高还是因为过多任务的调度问题，跟前面上下文切换次数的分析结果是一致的

### 总结

如果系统的上下文切换次数比较稳定，那么从数百到一万以内，都应该算是正常的。但当上下文切换次数超过一万次，或者切换次数出现数量级的增长时，就很可能已经出现了性能问题。

比如之前的天池比赛，如果用pidstat观察的话：

- **自愿上下文切换变多了**，说明进程都在等待资源，那么IO是关键问题。
- **非自愿上下文切换变多了**，说明进程都在被强制调度，也就是都在争抢 CPU，说明 CPU的确成了瓶颈。这个时候就要考虑CPU优化以及线程池的调整。
- **中断次数变多了**，说明 CPU 被中断处理程序占用，还需要通过查看 /proc/interrupts 文件来分析具体的中断类型。















