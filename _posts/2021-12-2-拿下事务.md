---
layout:     post
title:      拿下事务
subtitle:   
date:       2021-11-19
author:     Timer
header-img: img/the-first.png
catalog: false
tags:
    - Mysql
    - 数据库

---

## 事务是什么

一组sql，要么全成功，要么全失败。

事务是在引擎层实现的，mysql是个支持多引擎的系统，但不是所有引擎都支持事务，比如经典的innodb支持，myisam不支持。  



## 事务的特性

- **Atomicity**：**这组sql，全完成或者全失败，如果某个语句有问题，则回滚。**原子默认是最小的单位，也就是一组不可分割的操作。和JAVA里的AtomicXXX一样原理，只是JAVA里的要求的是一组底层指令，而MYSQL里的要求的是一组sql。

- **Consistency**：**事务开始前和开始后，所有的操作必须满足约束、触发器等等，保证数据库的一致性。**比如余额字段要求不小于0，而某个事务中有sql让余额小于0了，那这个事务则不能成功。

- **Isolation：**下面重点说。

- **Durability：**事务对数据库的影响必须是持久化的。  



## 隔离与隔离级别

当多个事务执行时，免不了出现一堆问题。主要有脏读（dirty read）、幻读（phantom read）、不可重复读（non-repeatable read）。

隔离级别就是为了解决这些问题。隔离级别越安全，效率就越低，很多时候需要找一个平衡点。

隔离级别分为四种，安全性由低到高，效率由高到低。

1. 读未提交（read uncomitted）：事务A没提交，事务B就能看到A的修改内容
2. 读提交（read committed）：事务A提交完，事务B才能看到A的修改内容
3. 可重复度（repeatable read）：不管事务A怎么改，事务B从头到尾看到的内容都是一致的
4. 串行化（serializable）：所有读和写操作都会加锁

底层实现的话，数据库会创建一个视图，查询以视图为准。

1：不需要视图，直接返回最新值。

2：每次sql执行的时候创建一个视图。

3：事务开始的时候创建一个视图。

4：用锁解决，不需要视图。

Oracle默认的是2，而Mysql默认的3，所以迁移的时候也要注意这一点。

每个事务都有各自对应的场景，比如现在要校对余额表和消费表，判断二者数据是否一致，不希望其他事务对当前校对的事务产生影响，这很明显就是需要可重复读的场景。  



## 事务隔离的实现

以可重复读为例。事务里的每个sql操作都有对应的回滚日志，比如事务A把1变成2，把2变成3，把3变成4，事务提交后的结果应当为4。但是这时事务提交失败，那么就要回滚到初始的值，也就是4->3，3->2，2->1这三个回滚操作。















































