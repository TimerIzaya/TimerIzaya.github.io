---
layout:     post
title:      进程->线程->协程
subtitle:   无处不在
date:       2021-10-23
author:     Timer
header-img: img/the-first.png
catalog: false
tags:
    - OS


---

### 前言

​		写了好几年的代码了，有时候杠起来问自己什么叫线程和进程的时候，也只能以一种狭义的方式去解释，“正在执行的程序”，“进程的更小单位”等等，依旧是模糊的、抽象的理解。这种一知半解的感觉很难受，所以这波总结一下，把它冲烂。



## 进程

首先，程序本质只是一段字符串，未启动的时候存在于磁盘中。启动程序就要把它编译成CPU可识别的机器码，也就是指令，然后加载进内存，让CPU从第一条指令开始依次执行。**可以看出，对于CPU，进程就是一串执行中的指令。**

其次，指令在执行的过程中，必然要涉及到堆栈的分配，也就是对内存的划分。**对于内存来说，进程是代码+堆栈内存+数据。**

同时，对于操作系统来说，需要记录进程的状态，也就是PCB，**Process Control Block主要用于描述当前进程的各种信息（说白了如果进程是个单机游戏，那么PCB就是存档）。**比如：

- **进程ID**
- **所属用户**
- **进程状态**：new、running、waiting、ready、terminated
- **进程优先级**
- **IO信息**：如果当前程序打开了某文件，恰好被挂起，**那么恢复的时候IO也需要恢复现场。**
- **CPU寄存器信息**：比如堆栈指针，当程序递归到某一层突然被挂起，**那么恢复的时候起码要知道当前栈帧的位置。**
- **程序计数器**：当前代码执行到第几行，如果程序突然被挂起，**那么恢复的时候起码要知道代码执行到到第几行。**
- **所属页表**：页表和进程是一对一的，如果进程改变，那么页表也要改变。

可以看出，PCB是线程的管理工具，也是进程的救心丸，和数据备份一个道理，如果被中断全靠PCB恢复。

**也可以看出，进程每一次切换，都要存储-恢复PCB，开销很大。**

###  linux中进程的五种状态

1. **R(TASK_RUNNING) –可执行状态：**通过将进程的task_struct结构放到CPU的可执行队列中，使进程变成R态。只有处在该状态的进程才有可能被进程调度器选中在CPU上执行。

2. **S(TASK_INTERRUPTIBLE) –可中断的睡眠状态 :**  当进程需要等待某件事的发生，比如socket连接等待对方输入时，进程的task_struct结构被放入相应事件的等待队列中。当事件被触发时，相应事件的等待队列中的某些进程就会被唤醒。

3. **D(TASK_UNINTERRUPTIBLE) –不可中断的睡眠状态: **  进程此时也是处于睡眠状态，但是不可以被kill掉，除非reboot，为了**保护内核状态下的某些流程不被打断**。

4. **T(TASK_STOPPED or TASK_TRACED) –暂停状态或跟踪状态：** TASK_STOPPED 和TASK_TRACED都表示进程被暂停下来，但不同的是TASK_STOPPED状态下，进程可以被SIGCONT信号唤醒，而TASK_TRACED下进程不能被该信号唤醒。TASK_TRACED状态通常发生在调试时，进程在断电处停下来，此时即被跟踪，只有当完成调试时，才能返回TASK_RUNNING状态。

5. **Z(TASK_DEAD) –退出状态，也称僵尸状态：**进程在退出的过程中，进程占有的所有资源会被回收，只剩下task_struct这个数据结构，也就是一副空壳，所以叫僵尸进程，如果父进程不退出，那么僵尸进程就会一直存在。  



## 线程

考虑这样一种情况，有一个10G的文件需要依次读入每一个字符进行转换处理，CPU4核。

如果只有进程，那么每次read()都要系统调用，进程就会挂起，所以进程会反复的切换，开销非常高。

**优化的本质就是去除无谓的操作**，可以看出，PCB里除了堆栈和寄存器信息，其他根本没必要切换。也就是说在操作系统分配的当前程序的内存空间中，完全可以再细分一条独立的控制流，共享当前PCB的大部分信息，减少切换的开销，这就是线程。

线程相比于进程能减少开销，主要体现在：

- **线程创建的速度快**，PCB里的大部分信息，线程都不需要去生成，而是直接使用。
- **线程销毁的速度快**，理由同上。
- **线程切换的速度快**，线程只有寄存器和栈是独立的，需要切换。尤其是对于页表这种信息，可以节省很多开销。
- **线程通信的速度快**，进程之间通信需要经过内核，线程不需要。

#### 从操作系统层面来说，线程有五种状态：

- **初始状态**：仅在语言层面创建了线程对象，还未与OS线程关联。
- **可运行状态（就绪状态）**：在OS层面创建了线程对象，可由CPU调用执行。
- **运行状态**：获取了CPU时间片，运行中的状态，当时间片用完，则又会回到**可运行状态**，会导致**线程的上下文切换**。
- **阻塞状态**：调用IO等系统中断操作，进入阻塞状态，阻塞完毕进入**可运行状态**。
- **终止状态**：线程生命周期结束。

#### 从Java API层面来说，线程有六种状态：

- **NEW**和**TERMINATED**和OS中一致。
- 当调用了start()方法之后，Java API层面的**Runnable**包含了OS层面中的可运行、运行和阻塞状态。（BIO导致的阻塞在JAVA中依然是Runnable）
- **Blocked**为目标被锁占用时候的阻塞，属于OS层面的阻塞。
- **Waiting**为无限时的等待，比如join，属于OS层面的阻塞。
- **Timed_waiting**是有限的等待，比如sleep，属于OS层面的阻塞

贴一下六种状态的演示：

```java
@Slf4j
public class APITest {
    public static void main(String[] args) throws InterruptedException, IOException {
        // 不启动 new
        Thread t1 = new Thread(() -> {

        }, "t1");

        // 无限执行 running
        Thread t2 = new Thread(() -> {
            while (true) {
            }
        }, "t2");
        t2.start();

        // 立即结束 terminated
        Thread t3 = new Thread(() -> {
        }, "t3");
        t3.start();

        // 对APITest加锁，睡眠 time_waiting
        Thread t4 = new Thread(() -> {
            synchronized (APITest.class) {
                try {
                    TimeUnit.SECONDS.sleep(10);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "t4");
        t4.start();

        // 无限等待t2 waiting
        Thread t5 = new Thread(() -> {
            try {
                t2.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "t5");
        t5.start();

        // 无限申请锁 blocked
        Thread t6 = new Thread(() -> {
            synchronized (APITest.class) {

            }
        }, "t6");
        t6.start();

        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        log.debug("t1 state {}", t1.getState());
        log.debug("t2 state {}", t2.getState());
        log.debug("t3 state {}", t3.getState());
        log.debug("t4 state {}", t4.getState());
        log.debug("t5 state {}", t5.getState());
        log.debug("t6 state {}", t6.getState());
        System.in.read();
    }
}
```

![image-20220102202009633](https://gitee.com/timerizaya/timer-pic/raw/master/img/image-20220102202009633.png)

















