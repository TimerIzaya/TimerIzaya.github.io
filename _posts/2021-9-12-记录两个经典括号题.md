---
layout:     post
title:      记录两个经典括号题
subtitle:   要学着不用具体的测试用例思考
date:       2021-9-12
author:     Timer
header-img: img/the-first.png
catalog: false
tags:
    - Algorithm


---

### [678. 有效的括号字符串](https://leetcode-cn.com/problems/valid-parenthesis-string/ )

### [[301. 删除无效的括号]](https://leetcode-cn.com/problems/remove-invalid-parentheses/)





## 678.有效的括号字符串

### 对于只有 左括号和有括号 的情况验证是否合法很简单：

遍历，遇见左括号加一分，遇见右括号减一分，全程分数必须保持在非负数，最后结果为0的话，则合法。



### 当加入星号之后：

星号的正则含义是任意字符，在这题表示可以是左右括号或者空字符。

那么可能的情况会变得非常复杂。



### 和无星情况的区别：

无星情况的分数是静态的，遍历到某一符号时，分数是固定的。而有星号的话，则不固定。

**分数不是固定的数，但是可以是一个固定的区间。**



### 思路：

同样对每一个字符进行打分，如果是左括号就+1，如果是右括号就-1，如果星号，则可能是+1、-1、+0。

所以定义一个当前分数区间的最大值max和最小值min。

当遇见左括号，max++，min++

当遇见右括号，max--，min--

当遇见星号，max++，min-- ，扩大可能的范围。同时注意，分数小于0的范围不考虑，分数小于0了就不合法了，所以min最小只能为0。

区间不合法的情况：

1. 在遍历过程中，分数可能取到的最大值都小于0，不合法。
2. 当遍历结束，分数可能取到的最小值不是0，不合法。



**空间复杂度：1**

**时间复杂度：n**

### 代码：

```java
class Solution {
    public boolean checkValidString(String s) {
        int[] range = new int[2];

        for(char c :s.toCharArray()){
            if(c == '('){
                range[0]++;
                range[1]++;
            }else if (c == ')'){
                range[0]--;
                range[1]--;
            }else{
                range[0]--;
                range[1]++;
            }
            range[0] = Math.max(range[0], 0); //保证左区间不小于0
            if(range[1] < 0){
                return false;
            }
        }
        return range[0] == 0;
    }
}

```



## 301.删除无效括号

首先，既然要最长有效括号，那肯定要先考虑生成所有有效括号，类似排列组合关系，考虑DFS、BFS。

其次，有效括号的判断可以由上文所说的计分来处理。

### 大体思路确定了，那么只需要考虑，DFS当递归到某一个char，是否选择要这个char。

1. 如果当前char是左括号，那么可以要，可以不要。
2. 如果当前char是右括号，那么如果是合法的话，可以要，可以不要，如果不合法，那么不要。
3. 如果当前char是其他字符，那么必定要它。

### 再考虑递归终止条件即可：

当依次判断直到最后字符串最后一位，开始判断是否保留这个有效括号字符串。

1. 分不为0，说明不合法，直接return。
2. 如果这个有效串的长度和记录的最长长度相同，则直接添加。
3. 如果这个有效串的长度比记录的最长长度还长，则clear掉存储结果的容器，再添加。

### 当DFS可以解决的时候，要考虑，是否可以剪枝（靠观察，随缘）：

可以发现，括号串，不管有效无效，它能生成的最多括号的对数，取决于有多少个左括号和右括号，也就是左右括号的最小值，是它可能的最大括号对数。

比如：（（（（（（  ））

右括号只有两个，那么当左括号保留了两个的时候，就没必要继续添加了，加了也是白加。

从而可以进行剪枝操作，优化DFS。



### 代码：

```
class Solution {

    //最大有效括号数
    private int max_len = 0;

    //结果集
    private Set<String> ans = new HashSet();

    //最大可能的括号对数
    private int max_score = 0;

    public List<String> removeInvalidParentheses(String s) {
        char[] cs = s.toCharArray();
        int cnt_l = 0, cnt_r = 0;
        for(char c : cs){
            cnt_l += c == '(' ? 1 : 0;
            cnt_r += c == ')' ? 1 : 0;
        }
        max_score = Math.min(cnt_l, cnt_r);
        dfs(cs, 0, 0, "");
        return new ArrayList<>(ans);
    }

    // cur 当前位置
    // score 当前得分
    // one 当前记录的括号串
    public void dfs(char[] cs, int cur, int score, String one){
        if(cur == cs.length){
            if(score != 0){
                return;
            }
            if(one.length() == max_len){
                ans.add(one);
            }else if (one.length() > max_len){
                ans.clear();
                ans.add(one);
                max_len = one.length();
            }
            return;
        }

        if(cs[cur] == '('){ 
            if(score + 1 <= max_score){
                 dfs(cs, cur + 1, score + 1, one + cs[cur]);
            }
            dfs(cs, cur + 1, score, one);
        }else if(cs[cur] == ')'){
            if(score > 0){
                dfs(cs, cur + 1, score - 1, one + cs[cur]);
            }
            dfs(cs, cur + 1, score, one);
        }else{
            dfs(cs, cur + 1, score, one + cs[cur]);
        }
    }

}

```























