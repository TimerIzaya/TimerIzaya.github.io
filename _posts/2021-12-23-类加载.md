---
layout:     post
title:      虚拟机类加载机制
subtitle:   JVM的“Exe”是怎么执行的
date:       2021-12-23
author:     Timer
header-img: img/the-first.png
catalog: false
tags:
    - Java
    - JVM

---

## 前言

​	这块内容是最颠覆我对Java理解的部分，也是耽误时间最久的，类加载这三个字越看越不明白。**类的本质是什么？为什么要加载？从哪加载到哪？既然底层是C++，那JVM执行的时候底层调用C++的new不就完事了？**  



## Java的new操作符的具体实现

```C++
// hotspot/src/share/vm/interpreter/interpreterRuntime.cpp
...
// HotSpot中new操作符的实现函数
IRT_ENTRY(void, InterpreterRuntime::_new(JavaThread* thread, ConstantPool* pool, int index))
  Klass* k_oop = pool->klass_at(index, CHECK);
  instanceKlassHandle klass (THREAD, k_oop);
  // Make sure we are not instantiating an abstract klass
  klass->check_valid_for_instantiation(true, CHECK);
  // Make sure klass is initialized
  klass->initialize(CHECK);
  // At this point the class may not be fully initialized
  // ...
  oop obj = klass->allocate_instance(CHECK);
  thread->set_vm_result(obj);
IRT_END
...
```

这段代码总结一下就是：**先生成一个Klass对象klass，再用klass生成oop对象obj，obj也就是java里的对象。**  



#### oop对象头：

```C++
// hotspot/src/share/vm/oops/oop.hpp
class oopDesc {
 ...
 private:
  // 用于存储对象的运行时记录信息，如哈希值、GC分代年龄、锁状态等
  volatile markOop  _mark;
  // Klass指针的联合体，指向当前对象所属的Klass对象
  union _metadata {
    // 未采用指针压缩技术时使用
    Klass*      _klass;
    // 采用指针压缩技术时使用
    narrowKlass _compressed_klass;
  } _metadata;
 ...
}
```

mark对象头不用多说，这里能看到关键的一点，就是Java每个对象都拥有一个klass指针，所以能够实现反射。  



#### oop对象体：

同时，Java对象的field也都存储在oop里，oop提供了一系列方法来获取和设置field，如下：

```C++
// hotspot/src/share/vm/oops/oop.hpp
class oopDesc {
 ... 
  // 返回成员属性的地址
  void*     field_base(int offset)        const;
  // 如果成员是基础类型，则用特有的方法
  jbyte*    byte_field_addr(int offset)   const;
  jchar*    char_field_addr(int offset)   const;
  jboolean* bool_field_addr(int offset)   const;
  jint*     int_field_addr(int offset)    const;
  jshort*   short_field_addr(int offset)  const;
  jlong*    long_field_addr(int offset)   const;
  jfloat*   float_field_addr(int offset)  const;
  jdouble*  double_field_addr(int offset) const;
  Metadata** metadata_field_addr(int offset) const;
  // 同样是成员的地址获取方法，在GC时使用
  template <class T> T* obj_field_addr(int offset) const;   
 ...
  // instanceOop获取和设置其成员属性的方法
  oop obj_field(int offset) const;
  volatile oop obj_field_volatile(int offset) const;
  void obj_field_put(int offset, oop value);
  void obj_field_put_raw(int offset, oop value);
  void obj_field_put_volatile(int offset, oop value);
  // 如果成员时基础类型，则使用其特有的方法，这里只列出针对byte类型的方法
  jbyte byte_field(int offset) const;
  void byte_field_put(int offset, jbyte contents);
 ...
}
```

其中第一个方法的实现如下：

```java
// hotspot/src/share/vm/oops/oop.inline.hpp
...
// 获取对象中field的地址
inline void* oopDesc::field_base(int offset) const { 
  return (void*)&((char*)this)[offset];
}
```

由上述代码可知，每个field在oop中都有一个偏移量。oop通过偏移量计算出field地址，再根据地址得到数据。  



#### OOP继承关系

```C++
// hotspot/src/share/vm/oops/oopsHierarchy.hpp
...
// Oop的继承体系
typedef class oopDesc*                            oop;
typedef class   instanceOopDesc*            instanceOop; //普通对象
typedef class   arrayOopDesc*                    arraysOop; //数组对象
typedef class     objArrayOopDesc*            objArrayOop;
typedef class     typeArrayOopDesc*            typeArrayOop;
...
```

  



#### 成员方法在哪里？

现在知道每个对象的元信息(mark)和成员变量(field)了。但成员方法不属于oop对象，而是从klass对象中获得。

C++的动态绑定是由虚函数表实现的，代价是每个对象都要维护一个虚函数表。

而Java由于是一切皆对象，每个对象维持一个虚函数表，开销会非常大。**JVM对此作出了优化，虚函数表不再由对象维护，而是由Class类型维护**，因此没有在oop里找到方法调用的逻辑，因为这部分代码在klass里。  

  

#### Klass是什么？

如下为HotSpot源码中对Klass的功能介绍：

> A Klass provides:
> ​ 1: language level class object (method dictionary etc.)
> ​ 2: provide vm dispatch behavior for the object
> Both functions are combined into one C++ class.

可见，Klass主要提供了两个功能：

（1）**用于表示Java类**。Klass中保存了一个Java对象的类型信息，包括类名、限定符、常量池、方法字典等。一个`class文件`被JVM加载之后，就会被解析成一个`Klass`对象存储在内存中。

（2）**实现对象的虚分派**（virtual dispatch）。所谓的虚分派，是JVM用来实现多态的一种机制。  



#### Klass的继承体系

```C++
// hotspot/src/share/vm/oops/oopsHierarchy.hpp
...
class Klass;  // Klass继承体系的最高父类
class   InstanceKlass;  // 表示一个Java普通类，包含了一个类运行时的所有信息
class     InstanceMirrorKlass;  // 表示java.lang.Class
class     InstanceClassLoaderKlass; // 主要用于遍历ClassLoader继承体系
class     InstanceRefKlass;  // 表示java.lang.ref.Reference及其子类
class   ArrayKlass;  // 表示一个Java数组类
class     ObjArrayKlass;  // 普通对象的数组类
class     TypeArrayKlass;  // 基础类型的数组类
...
```

其中，**InstanceKlass也就是Java里的Class类**，记录了一个类运行时的所有信息，源码如下所示：

```C++
// hotspot/src/share/vm/oops/instanceKlass.hpp
class InstanceKlass: public Klass {
...
  // 当前类的状态
  enum ClassState {
    allocated,  // 已分配
    loaded,  // 已加载，并添加到类的继承体系中
    linked,  // 链接/验证完成
    being_initialized,  // 正在初始化
    fully_initialized,  // 初始化完成
    initialization_error  // 初始化失败
  };
  // 当前类的注解
  Annotations*    _annotations;
  // 当前类数组中持有的类型
  Klass*          _array_klasses;
  // 当前类的常量池
  ConstantPool* _constants;
  // 当前类的内部类信息
  Array<jushort>* _inner_classes;
  // 保存当前类的所有方法.
  Array<Method*>* _methods;
  // 如果当前类实现了接口，则保存该接口的default方法
  Array<Method*>* _default_methods;
  // 保存当前类所有方法的位置信息
  Array<int>*     _method_ordering;
  // 保存当前类所有default方法在虚函数表中的位置信息
  Array<int>*     _default_vtable_indices;
  // 保存当前类的field信息（包括static field），数组结构为：
  // f1: [access, name index, sig index, initial value index, low_offset, high_offset]
  // f2: [access, name index, sig index, initial value index, low_offset, high_offset]
  //      ...
  // fn: [access, name index, sig index, initial value index, low_offset, high_offset]
  //     [generic signature index]
  //     [generic signature index]
  //     ...
  Array<u2>*      _fields;
...
}
```

  

#### 虚函数表

```C++
// hotspot/src/share/vm/oops/instanceKlass.hpp
class InstanceKlass: public Klass {
...  
  // 返回一个新的vtable，在类初始化时创建
  klassVtable* vtable() const;
  inline Method* method_at_vtable(int index);
..
}
// 以下为方法对应实现
// hotspot/src/share/vm/oops/instanceKlass.cpp
...
// vtable()的实现
klassVtable* InstanceKlass::vtable() const {
  return new klassVtable(this, start_of_vtable(), vtable_length() / vtableEntry::size());
}
// method_at_vtable()的实现
inline Method* InstanceKlass::method_at_vtable(int index)  {
  ... // 校验逻辑
  vtableEntry* ve = (vtableEntry*)start_of_vtable();
  return ve[index].method();
}
```

一个`klassVtable`可看成是由多个`vtableEntry`组成的数组，其中每个元素`vtableEntry`里面都包含了一个方法的地址。在进行虚分派时，JVM会根据方法在`klassVtable`中的索引，找到对应的`vtableEntry`，进而得到方法的实际地址，最后根据该地址找到方法的字节码并执行。

有了这些基础前提知识后，再来看类加载的过程，会更清澈。

从HotSpot的角度来说，整个类加载就是把磁盘中的Class文件加载到内存，对数据进行校验、解析和初始化，底层的C++生成了instanceKlass，也就是Java里可用的Class。  



## 类加载的过程

一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历**加载 、验证、准备、解析、初始化、使用**和**卸载**七个阶段，其中**验证、准备、解析**三个部分统称 为连接。

