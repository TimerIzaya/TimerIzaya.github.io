---
layout:     post
title:      虚拟机类加载机制
subtitle:   JVM的“Exe”是怎么执行的
date:       2021-12-23
author:     Timer
header-img: img/the-first.png
catalog: false
tags:
    - Java
    - JVM

---

## 前言

​	这块内容是最颠覆我对Java理解的部分，也是耽误时间最久的，类加载这三个字越看越不明白。**类的本质是什么？为什么要加载？从哪加载到哪？既然底层是C++，那JVM执行的时候底层调用C++的new不就完事了？**  



## Java的new操作符的具体实现

```C++
// hotspot/src/share/vm/interpreter/interpreterRuntime.cpp
...
// HotSpot中new操作符的实现函数
IRT_ENTRY(void, InterpreterRuntime::_new(JavaThread* thread, ConstantPool* pool, int index))
  Klass* k_oop = pool->klass_at(index, CHECK);
  instanceKlassHandle klass (THREAD, k_oop);
  // Make sure we are not instantiating an abstract klass
  klass->check_valid_for_instantiation(true, CHECK);
  // Make sure klass is initialized
  klass->initialize(CHECK);
  // At this point the class may not be fully initialized
  // ...
  oop obj = klass->allocate_instance(CHECK);
  thread->set_vm_result(obj);
IRT_END
...
```

这段代码总结一下就是：**先生成一个Klass对象klass，再用klass生成oop对象obj，obj也就是java里的对象。**

#### oop对象头主要有两个属性：

```C++
// hotspot/src/share/vm/oops/oop.hpp
class oopDesc {
 ...
 private:
  // 用于存储对象的运行时记录信息，如哈希值、GC分代年龄、锁状态等
  volatile markOop  _mark;
  // Klass指针的联合体，指向当前对象所属的Klass对象
  union _metadata {
    // 未采用指针压缩技术时使用
    Klass*      _klass;
    // 采用指针压缩技术时使用
    narrowKlass _compressed_klass;
  } _metadata;
 ...
}
```

mark对象头不用多说，这里能看到关键的一点，就是Java每个对象都拥有一个klass指针，所以能够实现反射。

#### oop对象体：

同时，Java对象的field也都存储在oop里，oop提供了一系列方法来获取和设置field，如下：

```C++
// hotspot/src/share/vm/oops/oop.hpp
class oopDesc {
 ... 
  // 返回成员属性的地址
  void*     field_base(int offset)        const;
  // 如果成员是基础类型，则用特有的方法
  jbyte*    byte_field_addr(int offset)   const;
  jchar*    char_field_addr(int offset)   const;
  jboolean* bool_field_addr(int offset)   const;
  jint*     int_field_addr(int offset)    const;
  jshort*   short_field_addr(int offset)  const;
  jlong*    long_field_addr(int offset)   const;
  jfloat*   float_field_addr(int offset)  const;
  jdouble*  double_field_addr(int offset) const;
  Metadata** metadata_field_addr(int offset) const;
  // 同样是成员的地址获取方法，在GC时使用
  template <class T> T* obj_field_addr(int offset) const;   
 ...
  // instanceOop获取和设置其成员属性的方法
  oop obj_field(int offset) const;
  volatile oop obj_field_volatile(int offset) const;
  void obj_field_put(int offset, oop value);
  void obj_field_put_raw(int offset, oop value);
  void obj_field_put_volatile(int offset, oop value);
  // 如果成员时基础类型，则使用其特有的方法，这里只列出针对byte类型的方法
  jbyte byte_field(int offset) const;
  void byte_field_put(int offset, jbyte contents);
 ...
}
```

其中第一个方法的实现如下：

```java
// hotspot/src/share/vm/oops/oop.inline.hpp
...
// 获取对象中field的地址
inline void* oopDesc::field_base(int offset) const { 
  return (void*)&((char*)this)[offset];
}
```

由上述代码可知，每个field在oop中都有一个偏移量。oop通过偏移量计算出field地址，再根据地址得到数据。

#### 成员方法在哪里？

现在知道每个对象的元信息(mark)和成员变量(field)了，成员变量不属于oop对象，而是从klass对象中获得。

C++的动态绑定是由虚函数表实现的，代价是每个对象都要维护一个虚函数表。

而Java由于是一切皆对象，所以要









