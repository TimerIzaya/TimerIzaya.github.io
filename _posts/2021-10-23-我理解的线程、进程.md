---
layout:     post
title:      我理解的线程、进程
subtitle:   拒绝模糊、抽象的概念
date:       2021-10-23
author:     Timer
header-img: img/the-first.png
catalog: false
tags:
    - OS


---

### 前言

​		写了好几年的代码了，有时候杠起来问自己什么叫线程和进程的时候，也只能以一种狭义的方式去解释，“正在执行的程序”，“进程的更小单位”等等，依旧是模糊的、抽象的理解。这种一知半解的感觉很难受，所以这波总结一下，把它冲烂。



## 进程

首先，程序本质只是一段字符串，未启动的时候存在于磁盘中。启动程序就要把它编译成CPU可识别的机器码，也就是指令，然后加载进内存，让CPU从第一条指令开始依次执行。**可以看出，对于CPU，进程就是一串执行中的指令。**

其次，指令在执行的过程中，必然要涉及到堆栈的分配，也就是对内存的划分。**对于内存来说，进程是代码+堆栈内存+数据。**

同时，对于操作系统来说，需要记录进程的状态，也就是PCB，**Process Control Block主要用于描述当前进程的各种信息。**比如：

- **进程ID**
- **所属用户**
- **进程状态**：new、running、waiting、ready、terminated
- **进程优先级**
- **IO信息**：如果当前程序打开了某文件，恰好被挂起，那么恢复的时候IO也需要恢复现场。
- **CPU寄存器信息**：比如堆栈指针，当程序递归到某一层突然被挂起，那么恢复的时候起码要知道当前栈帧的位置。
- **程序计数器**：当前代码执行到第几行，如果程序突然被挂起，那么恢复的时候起码要知道当前执行到到哪儿了。
- **所属页表**

可以看出，PCB是线程的管理工具，也是进程的救心丸，和数据备份一个道理，如果被中断全靠PCB恢复。

**也可以看出，进程每一次切换，都要存储-恢复PCB，开销很大。**



## 线程

考虑这样一种情况，有一个10G的文件需要依次读入每一个字符进行转换处理，CPU是4核的。

如果只有进程，那么每次read()都要系统调用，进程就会挂起，所以进程会反复的切换，开销非常高。

**优化的本质就是去除无谓的操作**，可以看出，PCB里除了堆栈和寄存器信息，其他根本没必要切换。也就是说在操作系统分配的当前程序的内存空间中，完全可以再细分一条独立的控制流，共享当前PCB的大部分信息，减少切换的开销，这就是线程。

线程相比于进程能减少开销，主要体现在：

- **线程创建的速度快**，PCB里的大部分信息，线程都不需要去生成，而是直接使用。
- **线程销毁的速度快**，理由同上。
- **线程切换的速度快**，线程只有寄存器和栈是独立的，需要切换。尤其是对于页表这种信息，可以节省很多开销。
- **线程通信的速度快**，进程之间通信需要经过内核，线程不需要。



























