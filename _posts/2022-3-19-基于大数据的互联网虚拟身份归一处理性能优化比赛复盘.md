---
5layout:     post
title:      基于大数据的互联网虚拟身份归一处理性能优化比赛复盘
subtitle:   
date:       2022-3-19
author:     Timer
header-img: img/the-first.png
catalog: false
tags:
    - 竞赛
 
---

<img src="https://gitee.com/timerizaya/timer-pic/raw/master/img/image-20220319161634612.png" alt="image-20220319161634612" style="zoom:67%;" />

## 部分数据实例

#### Accounts

```txt
0 73cc29d320aabdad
1 b56a14dac2a53487
2 dd0d4423b3a76ddc
3 dd4558dd9a60aa30
4 b4a1ad3adbbbaa23
5 ba73abca485d44ad
6 cbb055c1d2d6146c
7 bccd087b572aba40
8 9ba12dc7c9c2cd2d
9 b457d5dad2ba0b41
10 6c31b59aaa0aad4d
```

##### Relations

```
4831342 134d0902bdd0641b 2618346 ad99ac3738bca8ca
4344645 da57218c467d4695 3429183 654b5dd92dda2d2b
2572891 c93d9195c2a15a62 2248096 a6243abb3a3bcbbc
1912430 adcbc16d41492a0d 794101 a3ddb7504963571a
4262423 5a5d1bb29ba65c8b 3767429 86c9b0acba8a7a0b
3605550 b0dddddaa0b76687 1728813 33b4658d9c0bc902
2633634 dcabda0300db8b06 251138 b7cacc687adb9008
1022533 1ca9b4bbcabab9ba 496889 cb05dac9bdcd1987
3922970 a6cbb04c1ab9b9aa 1929729 6d9bb6a653baa0c5
2677481 1bd497acdd9dba7c 1275724 141d20da73a196aa
```

#### 注意，账号长度为固定的16位



## 读Accounts

老生常谈多线程IO，首先对文件进行逻辑分割成线程数。MMAP读，同时进行解析。

很明显，Relation文件里的账号字符串是不需要的，只要在Account里读即可。

这里有一个最最最核心的优化点，也是我不能进1s的最大原因。

读account的时候，不需要把16位的账号也读出来，因为从头到尾account根本不需要我们处理，同时整个过程也没有断电操作，只要在数组中记录它在buffer中的位置即可，到时候写的时候直接0拷贝。



## 读Relations

同样多线程读，分块无锁化操作。遇见空格直接跳16位。这时候可以获得并查集需要的两对数据，src和des。

这里的关键点在于：

一开始的直接思路是创建一个二维数组edges，第一维度是src或者des，第二维是关系对的总个数。

但这种做法肯定是很蠢的，多线程读文件然后写到数组中，需要用CAS或者写锁保证一个个写进来，那多线程读就根本没有了意义。

**所以首先的改进**就是多空间换低并发，和多段锁的策略是类似的。把二维数组升成三维数组，一维是src和des，二维是线程个数，三维是总对数除以线程个数。

但这样做涉及到一个老生常谈的问题：**虽然多维数组在内存中是顺序排放的，但多维数组顺序读写是必然比一维数组慢的。**

由于两者都是顺序排放，所以顺序读写的话，CPU缓存是不受影响的。关键在于多次寻址的计算。

如果是一维数组，那么寻址只需要address+offset。

如果是多维数组，那么寻址需要address + (一行元素个数)*(当前行) + offset 这样更复杂的计算。

同时java还会对数组有边界检查，也就是本来只要做一次边界检查，现在需要做**两次**！

**所以在考虑性能优化的时候，能不用多维尽量不要用多维，最好压缩成一维数组使用。**

所以读关系文件最大的两个优化点在于，多段锁机制 + 数组降维。











































